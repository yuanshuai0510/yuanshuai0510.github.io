<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ysocks.gitee.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8-lambda">
<meta property="og:url" content="http://ysocks.gitee.io/2020/04/15/java8-lambda/index.html">
<meta property="og:site_name" content="YSocket&#39;s Blog">
<meta property="og:description" content="Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-15T02:41:00.000Z">
<meta property="article:modified_time" content="2020-06-04T03:48:33.000Z">
<meta property="article:author" content="YSocket">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ysocks.gitee.io/2020/04/15/java8-lambda/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java8-lambda | YSocket's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YSocket's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YSocket's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">YSocket Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ysocks.gitee.io/2020/04/15/java8-lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YSocket">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YSocket's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java8-lambda
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 10:41:00" itemprop="dateCreated datePublished" datetime="2020-04-15T10:41:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-04 11:48:33" itemprop="dateModified" datetime="2020-06-04T11:48:33+08:00">2020-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。</p>
<a id="more"></a>
<p>Java8在使世界上最受欢迎的编程语言之一在接纳函数式编程的过程中向前迈了一大步。为了支持函数式编程，编程语言必须将函数作为<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6" target="_blank" rel="noopener">第一类对象</a>。在Java8之前，如果没有使用一个匿名内部类模板是没法写出清晰的函数式代码的。随着lambda表达式的引入，函数已经成为第一类对象，并能够像其它变量一样被到处传递。</p>
<p>lambda表达式允许你定义一个不与标识符绑定的匿名函数。你可以像编程语言中的其它概念一样使用它们，比如变量的声明。当一个编程语言需要支持高阶函数时，就需要用到lambda表达式。高阶函数是指以其它函数作为参数或者返回函数作为结果的函数。</p>
<blockquote>
<p>这一节的代码在<a href="https://github.com/shekhargulati/java8-the-missing-tutorial/tree/master/code/src/main/java/com/shekhargulati/java8_tutorial/ch02" target="_blank" rel="noopener">ch02</a>包中</p>
</blockquote>
<p>现在，随着在Java8中引进了lambda表达式，Java已经支持高阶函数。让我来看一个lambda表达式的典型例子——<code>Collections</code>类中的<code>sort</code>方法。<code>sort</code>方法有两种变体——一种以一个<code>List</code>作为参数，另一个以<code>List</code>和<code>Comparator</code>作为参数。如下面的代码块所示，第二种<code>sort</code>方法是一个接受lambda表达式的高阶函数的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"shekhar"</span>, <span class="string">"rahul"</span>, <span class="string">"sameer"</span>);</span><br><span class="line">Collections.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>

<p>上面的代码将姓名链表按照元素的长度进行排序。该程序的输出如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rahul, sameer, shekhar]</span><br></pre></td></tr></table></figure>

<p>上面代码块中的表达式<code>(first, second) -&gt; first.length() - second.length()</code>是一个<code>Comparator&lt;String&gt;</code>类型的lambda表达式。</p>
<ul>
<li><code>(first, second)</code>是比较器<code>Comparator</code>的<code>compare</code>方法。</li>
<li><code>first.length() - second.length()</code> 是用来比较两个名字长度的方法实体。</li>
<li><code>-&gt;</code>是lambda操作符，用来将参数和方法体分离开。</li>
</ul>
<p>在我们继续深挖Java8的lambda表达式之前，让我们来看看lambda的历史来理解为什么会存在lambda。</p>
<h2 id="lambda的历史"><a href="#lambda的历史" class="headerlink" title="lambda的历史"></a>lambda的历史</h2><p>lambda表达式源自λ演算。<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a>由<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87" target="_blank" rel="noopener">Alonzo Church</a>在将带有函数的符号计算进行公式化时提出。λ演算是具有图灵完备性的，它通过数学形式来展现计算过程。图灵完备性表示你可以通过lambda表达任何的数学计算。</p>
<p>λ演算成为了函数式编程语言的一个坚实的理论基础。很多有名的函数式编程语言，像Haskell和Lisp都是构建在λ演算的基础上的。高阶函数的概念，比如接受其他函数为输入的函数也来自λ演算。</p>
<p>λ演算的核心概念是表达式。一个lambda表达式可以表示为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; :&#x3D; &lt;variable&gt; | &lt;function&gt;| &lt;application&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>variable</strong>–变量就是类似x,y,z的占位符，它们用来表示具体的像1,2之类的值，或者lambda方法。</li>
<li><strong>functrion</strong>–这是一个匿名的方法定义，它需要一个变量，并产生另一个lambda表达式。例如，<code>λx.x*x</code>是一个用来计算数的平方的方法。</li>
<li><strong>application</strong>–这是将具体的参数应用在函数上的行为。假设你想得到10的平方，那么在λ演算中你会写一个平方函数<code>λx.x*x</code>，并把10代入。这个函数应用将得到<code>(λx.x*x) 10 = 10*10 = 100</code>。你不仅仅能够代入简单的像10一样的值，你可以将一个函数代入另一个函数来得到一个新的函数。例如，<code>(λx.x*x) (λz.z+10)</code>将会生成一个函数<code>λz.(z+10)*(z+10)</code>。现在，你可以用这个函数得到一个数加上10以后的平方。这是一个高阶函数的例子。</li>
</ul>
<p>现在你理解了λ演算和它在函数式编程语言中的影响。让我们来学习它是如何在Java8中实现的。</p>
<h2 id="在Java8之前传递行为的方式"><a href="#在Java8之前传递行为的方式" class="headerlink" title="在Java8之前传递行为的方式"></a>在Java8之前传递行为的方式</h2><p>在Java8之前，唯一能够用来传递行为的方式是通过匿名类。假设你想要在用户完成注册的同时在另一个线程中给该用户发送一封邮件。在Java8之前，你会写出类似下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sendEmail(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sending email..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p><code>sendEmail</code>方法拥有如下的方法签名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(Runnable runnable)</span></span></span><br></pre></td></tr></table></figure>

<p>上面提到的代码的问题不仅仅是我们需要封装我们的行为，如将<code>run</code>方法直接放在一个对象中，更严重的问题是它丢失了程序员的意图，如将行为传递到<code>sendEmail</code>方法中。如果你使用过Guava类库，你肯定感受到了编写匿名类的痛苦。一个简单的用来过滤所有任务的标题中有<strong>lambda</strong>的例子如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;Task&gt; lambdaTasks = Iterables.filter(tasks, <span class="keyword">new</span> Predicate&lt;Task&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input.getTitle().contains(<span class="string">"lambda"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>有了Java8的Stream API，你可以在不使用像Guava一样的第三方库的情况下写出上面提及的代码。我们将在<a href="">第三章</a>中讲解Stream，敬请期待。</p>
<h2 id="Java8-lambda表达式"><a href="#Java8-lambda表达式" class="headerlink" title="Java8 lambda表达式"></a>Java8 lambda表达式</h2><p>在Java8中，我们将使用lambda表达式写出如下的代码。这与我们上面提及过的代码段相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendEmail(() -&gt; System.out.println(<span class="string">"Sending email..."</span>));</span><br></pre></td></tr></table></figure>

<p>上面的展示的代码非常简练，也没有污染程序员想要传递的行为。<code>()</code>用来表示这个lambda表达式没有参数，像<code>Runnable</code>接口中的<code>run</code>方法就没有任何参数。<code>-&gt;</code>是将参数和用来打印出<code>Sending email</code>的方法主体分隔开的lambda操作符。</p>
<p>让我再来看看<code>Collections.sort</code>这个例子来了解lambda表达式是如何使用参数的。为了使名字能够按照它们的长度进行排列，我们向排序方法传入了一个<code>Comparator</code>。该<code>Comparator</code>如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>我们编写的lambda表达式与<code>Comparator</code>接口中的<code>compare</code>方法相关联。<code>compare</code>方法的签名如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>T</code>是传给<code>Comparator</code>接口的类型参数。由于我们是对一组表示名字的字符串进行操作，所以这个例子中它将是字符串类型的。在lambda表达式中我们不需要特意提供该类型——字符串。<code>javac</code>编译器会从上下文中推断出它的类型信息。由于我们在给一组字符串排序，Java编译器会推测出两个参数都应该是字符串，而<code>compare</code>方法只标明需要<code>T</code>这一种类型。像这样通过上下文推断类型的行为称作类型推断。Java8优化了Java原有的类型推断机制，使得它更具有鲁棒性，并能够更好地支持lambda表达式。<code>javac</code>会在后台寻找与你lambda表达式相关的信息，并使用该信息来找到参数正确的类型。</p>
<blockquote>
<p>在大多数情况下，<code>javac</code>会从上下文中推断出类型。如果由于上下文缺失或不完整导致代码不能进行编译，它也就不能推断出类型。例如如果我们将<code>String</code>的类型信息从<code>Comparator</code>中移除，那么代码会像下面一样编译失败。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator comparator = (first, second) -&gt; first.length() - second.length(); <span class="comment">// compilation error - Cannot resolve method 'length()'</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式是如何在Java8中工作的？"><a href="#lambda表达式是如何在Java8中工作的？" class="headerlink" title="lambda表达式是如何在Java8中工作的？"></a>lambda表达式是如何在Java8中工作的？</h2><p>你也许已经发现lambda表达式是与上面例子中的<code>Comparator</code>类似的一些接口。你不能对任意的接口使用lambda表达式。<strong><em>只有那些除了Object的方法外只定义了唯一抽象方法的接口可以使用lambda表达式。</em></strong>这一类的接口被称作<strong>函数式接口</strong>，它们可以通过<code>@FunctionalInterface</code>注解来进行注解。如下所示，<code>Runnable</code>接口就是一个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code>注解不是强制需要的，它能够帮助其他工具知道这个接口是一个函数式接口，以此展现出有意义的行为。如果你试图编译一个有<code>@FunctionalInterface</code>的接口，而该接口有多个抽象方法，那么编译器将会抛出一个<strong><em>发现多个没有重写的抽象方法</em></strong>的异常。同样的，如果你对一个没有任何方法的接口添加<code>@FunctionalInterface</code>的注解，比如一个标记接口，那么你将会得到一条<strong><em>没有找到目标方法的</em></strong>的消息。</p>
<p>让我们来解答一个你也许会想到的最重要的问题。<strong><em>Java8中的lambda表达式是仅仅针对匿名类的语法糖吗，或者说函数式接口是如何转换为字节码的？</em></strong>简单的答案是<strong>不是</strong>。Java8不使用匿名内部类主要有两个原因：</p>
<ol>
<li><p><strong>性能开销</strong>：如果lambda表达式是通过使用匿名类来实现的，那么每一个lambda表达式都要在磁盘上产生一个文件。如果这些类在JVM启动时被加载，那么JVM的启动时间将会增加，因为所有的类在使用前都要进行加载和验证。</p>
</li>
<li><p><strong>未来改变的可能性</strong>：如果Java8的设计者从开始就使用了匿名类，那么这将限制lambda表达式的实现方式在将来的变化。</p>
</li>
</ol>
<h3 id="使用invokedynamic"><a href="#使用invokedynamic" class="headerlink" title="使用invokedynamic"></a>使用invokedynamic</h3><p>Java8设计者决定使用在Java7中添加的<code>invokedynamic</code>指令来在运行时推迟编译策略的执行。当<code>javac</code>编译代码的时候，它会捕捉到lambda表达式并生成一个<code>invokedynamic</code>的调用（被叫做lambda工厂）。当<code>invokedynamic</code>命令被调用时，它会返回一个lambda要转化的函数式接口的实例。例如，我来查看<code>Collections.sort</code>的字节码，它如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_3</span><br><span class="line">       1: anewarray     #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String</span><br><span class="line">       4: dup</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: ldc           #3                  &#x2F;&#x2F; String shekhar</span><br><span class="line">       8: aastore</span><br><span class="line">       9: dup</span><br><span class="line">      10: iconst_1</span><br><span class="line">      11: ldc           #4                  &#x2F;&#x2F; String rahul</span><br><span class="line">      13: aastore</span><br><span class="line">      14: dup</span><br><span class="line">      15: iconst_2</span><br><span class="line">      16: ldc           #5                  &#x2F;&#x2F; String sameer</span><br><span class="line">      18: aastore</span><br><span class="line">      19: invokestatic  #6                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;Arrays.asList:([Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;util&#x2F;List;</span><br><span class="line">      22: astore_1</span><br><span class="line">      23: invokedynamic #7,  0              &#x2F;&#x2F; InvokeDynamic #0:compare:()Ljava&#x2F;util&#x2F;Comparator;</span><br><span class="line">      28: astore_2</span><br><span class="line">      29: aload_1</span><br><span class="line">      30: aload_2</span><br><span class="line">      31: invokestatic  #8                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;Collections.sort:(Ljava&#x2F;util&#x2F;List;Ljava&#x2F;util&#x2F;Comparator;)V</span><br><span class="line">      34: getstatic     #9                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      37: aload_1</span><br><span class="line">      38: invokevirtual #10                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      41: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该字节码有意思的地方在第23行<code>23: invokedynamic #7,  0              // InvokeDynamic #0:compare:()Ljava/util/Comparator;</code>，也就是生成一个<code>invokedynamic</code>的地方。</p>
<p>第二步是将lambda表达式的主体部分转化成通过<code>invokedynamic</code>指令调用的方法。这一步让JVM实现者能够自由地选取他们自己的策略。我省略了这个话题相关的内容，你可以在<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html中阅读到更多的内容。" target="_blank" rel="noopener">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html中阅读到更多的内容。</a></p>
<h2 id="匿名类-vs-lambda"><a href="#匿名类-vs-lambda" class="headerlink" title="匿名类 vs lambda"></a>匿名类 vs lambda</h2><p>让我们通过比较匿名类和lambda表达式来比较它们的不同。</p>
<ol>
<li>在匿名类中，<code>this</code>表示匿名类自己，而在lambda表达式中，<code>this</code>表示包含了lambda表达式的类。</li>
<li>你可以在匿名类这个封闭类中隐藏变量。在lambda表达式中这么做时将产生一个编译错误。</li>
<li>lambda表达式的类型是由上下文决定的，而匿名类的类型是由你创建匿名类时指定的。</li>
</ol>
<h2 id="我需要自己编写函数式接口吗？"><a href="#我需要自己编写函数式接口吗？" class="headerlink" title="我需要自己编写函数式接口吗？"></a>我需要自己编写函数式接口吗？</h2><p>Java8默认提供了好多函数式编程接口来供你在代码中使用。它们在<code>java.util.function</code>包中。让我们看一下其中的一部分。</p>
<h3 id="java-util-function-Predicate"><a href="#java-util-function-Predicate" class="headerlink" title="java.util.function.Predicate"></a>java.util.function.Predicate<T></h3><p>这个函数式接口被用来定义某些情形的检查，类似于断言。<code>Predicate</code>接口有一个叫做<code>test</code>的方法，它以泛型<code>T</code>为参数，返回一个布尔值。举例来说，如果我们想从一串名字中找到所有以<strong>s</strong>开头的名字，那么我们将向下面这样使用<code>Predicate</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; namesStartingWithS = name -&gt; name.startsWith(<span class="string">"s"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="java-util-function-Consumer"><a href="#java-util-function-Consumer" class="headerlink" title="java.util.function.Consumer"></a>java.util.function.Consumer<T></h3><p>这个函数式接口被用来执行一些不用产生输出的动作。<code>Comsumer</code>接口有一个以泛型<code>T</code>为参数且没有返回值的<code>accept</code>方法。比如将一条给定的信息通过邮件发出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; messageConsumer = message -&gt; System.out.println(message);</span><br></pre></td></tr></table></figure>

<h3 id="java-util-function-Function-lt-T-R-gt"><a href="#java-util-function-Function-lt-T-R-gt" class="headerlink" title="java.util.function.Function&lt;T,R&gt;"></a>java.util.function.Function&lt;T,R&gt;</h3><p>这个函数式接口接受一个参数并产生一个结果。例如，如果我们想要将姓名列表中的所有名字都大写，我们可以写一个像下面这样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, String&gt; toUpperCase = name -&gt; name.toUpperCase();</span><br></pre></td></tr></table></figure>

<h3 id="java-util-function-Supplier"><a href="#java-util-function-Supplier" class="headerlink" title="java.util.function.Supplier"></a>java.util.function.Supplier<T></h3><p>这个函数式接口不需要任何参数，却会产生一个值。这可以被用来像下面这样生成唯一标志码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; uuidGenerator= () -&gt; UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>

<p>我们将在这一系列教程中涉及更多的函数式接口。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时候你会创建一些只调用特定方法的lambda表达式，比如<code>Function&lt;String, Integer&gt; strToLength = str -&gt;
str.length();</code>。这个lambda只在<code>String</code>对象上调用<code>length()</code>方法。这种情况可以通过使用方法引用来简化成<code>Function&lt;String, Integer&gt;
strToLength = String::length;</code>。这可以被看做是只调用单个方法的lambda表达式的简化标记。在该表达式<code>String::length</code>中，<code>String</code>是目标引用，<code>::</code>是分隔符，<code>length</code>是在目标引用中将会被调用的方法。你在静态方法和实例方法中都可以使用方法引用。</p>
<h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>假设我们要找到一串数中最大的一个，那么我们可以写一个像<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn =
Collections::max</code>这样的方法引用。<code>max</code>是<code>Collections</code>类中一个以<code>list</code>为参数的静态方法。然后你可以像<code>maxFn.apply(Arrays.asList(1, 10, 3, 5))</code>这样来调用。上面的lambda表达式是与<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn = (numbers) -&gt;
Collections.max(numbers);</code>等价的。</p>
<h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>这是一类为实例方法使用的方法引用，比如在<code>String::toUpperCase</code>在<code>String</code>引用上调用了<code>toUpperCase</code>方法。你也可以对有参数的方法使用方法引用，像<code>BiFunction&lt;String,
String, String&gt; concatFn = String::concat</code>。<code>concatFn</code>可以像<code>concatFn.apply(&quot;shekhar&quot;, &quot;gulati&quot;)</code>这样被调用。<code>concat</code>方法是字符串对象的需要一个参数的方法，形式为<code>&quot;shekhar&quot;.concat(&quot;gulati&quot;)</code>。</p>
<h2 id="练习-gt-gt-写自己的lambda"><a href="#练习-gt-gt-写自己的lambda" class="headerlink" title="练习&gt;&gt;写自己的lambda"></a>练习&gt;&gt;写自己的lambda</h2><p>让我们看一下下面的代码，并把我们学的应用起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks);</span><br><span class="line">        <span class="keyword">for</span> (String title : titles) &#123;</span><br><span class="line">            System.out.println(title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.getType() == TaskType.READING) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码首先从一个工具方法<code>getTasks</code>中获取所有的任务。我们对<code>getTasks</code>方法的内部实现不感兴趣。<code>getTasks</code>方法可以从web、数据库或者内存中来获取任务。一旦你有了任务，我们过滤出所有的阅读任务并抽取出这些任务的标题。我们将抽取的标题存入一个链表并最终返回所有的阅读标题。</p>
<p>让我们从最简单的重构开始——通过方法引用在链表上使用<code>foreach</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks);</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.getType() == TaskType.READING) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>Predicate&lt;T&gt;</code>来过滤我们的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING);</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>Function&lt;T,R&gt;</code>来从我们的任务中抽取标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING, task -&gt; task.getTitle());</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, Function&lt;Task, R&gt; extractor)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(extractor.apply(task));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对提取器使用方法引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">    List&lt;String&gt; titles = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getTitle);</span><br><span class="line">    titles.forEach(System.out::println);</span><br><span class="line">    List&lt;LocalDate&gt; createdOnDates = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getCreatedOn);</span><br><span class="line">    createdOnDates.forEach(System.out::println);</span><br><span class="line">    List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Function.identity());</span><br><span class="line">    filteredTasks.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以通过编写我们自己的<strong>函数式接口</strong>，这样可以清楚地描述开发者的意图。我们可以创建一个继承于<code>Function</code>接口的<code>TaskExtractor</code>接口。该接口的输入类型被限定为<code>Task</code>，输出类型由lambda的实现决定。这样由于输入类型始终是<code>Task</code>，开发者只需要关注返回值的类型，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, TaskExtractor.identityOp());</span><br><span class="line">        filteredTasks.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">filterAndExtract</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, TaskExtractor&lt;R&gt; extractor)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(extractor.apply(task));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TaskExtractor</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">Task</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TaskExtractor&lt;Task&gt; <span class="title">identityOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/04/15/Stream-API/" rel="next" title="Java8-Stream API">
      Java8-Stream API <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda的历史"><span class="nav-number">1.</span> <span class="nav-text">lambda的历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在Java8之前传递行为的方式"><span class="nav-number">2.</span> <span class="nav-text">在Java8之前传递行为的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8-lambda表达式"><span class="nav-number">3.</span> <span class="nav-text">Java8 lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda表达式是如何在Java8中工作的？"><span class="nav-number">4.</span> <span class="nav-text">lambda表达式是如何在Java8中工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用invokedynamic"><span class="nav-number">4.1.</span> <span class="nav-text">使用invokedynamic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名类-vs-lambda"><span class="nav-number">5.</span> <span class="nav-text">匿名类 vs lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我需要自己编写函数式接口吗？"><span class="nav-number">6.</span> <span class="nav-text">我需要自己编写函数式接口吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-function-Predicate"><span class="nav-number">6.1.</span> <span class="nav-text">java.util.function.Predicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-function-Consumer"><span class="nav-number">6.2.</span> <span class="nav-text">java.util.function.Consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-function-Function-lt-T-R-gt"><span class="nav-number">6.3.</span> <span class="nav-text">java.util.function.Function&lt;T,R&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-function-Supplier"><span class="nav-number">6.4.</span> <span class="nav-text">java.util.function.Supplier</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">7.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法引用"><span class="nav-number">7.1.</span> <span class="nav-text">静态方法引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例方法引用"><span class="nav-number">7.2.</span> <span class="nav-text">实例方法引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习-gt-gt-写自己的lambda"><span class="nav-number">8.</span> <span class="nav-text">练习&gt;&gt;写自己的lambda</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YSocket</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YSocket</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
