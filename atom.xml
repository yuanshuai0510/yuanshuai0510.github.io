<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YSocket&#39;s Blog</title>
  
  <subtitle>YSocket Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ysocks.gitee.io/"/>
  <updated>2020-08-22T12:40:40.944Z</updated>
  <id>http://ysocks.gitee.io/</id>
  
  <author>
    <name>YSocket</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot多模块项目中配置国际化</title>
    <link href="http://ysocks.gitee.io/2020/08/22/springboot-multi-module-i18n/"/>
    <id>http://ysocks.gitee.io/2020/08/22/springboot-multi-module-i18n/</id>
    <published>2020-08-22T12:34:00.000Z</published>
    <updated>2020-08-22T12:40:40.944Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://www.cnblogs.com/weixinya/p/12893531.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixinya/p/12893531.html</a></p><p>在多个module组成的SpringBoot项目中，可以为每个module单独配置属于自己的国际化资源。</p><ol><li>模块单独添加国际化配置文件<br>每个module单独配置一套配置文件；需要注意的是：配置文件basename不能出现重复，否则会出现配置文件被其他模块的同名配置文件屏蔽的情况！这里建议使用各个module的模块名作为配置文件的basename，既避免出现重复，又逻辑清晰优雅。</li><li>配置查找国际化资源路径<br>在程序入口所在包下application.yml配置文件中，配置所引用的module中的国际化路径，通过“,”来配置多个module的国际化资源文件。如下所示：<br>application.yml中多module国际化配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  messages:</span><br><span class="line">    basename: i18n&#x2F;common,i18n&#x2F;publicRes,i18n&#x2F;roleRight,i18n&#x2F;userMng</span><br><span class="line">    encoding: UTF-8</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://www.cnblogs.com/weixinya/p/12893531.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/weixinya/p/12893531.
      
    
    </summary>
    
    
    
      <category term="spring boot" scheme="http://ysocks.gitee.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>mac查找指定文件类型下包含某个字符串的文件</title>
    <link href="http://ysocks.gitee.io/2020/08/21/find-file-include-same-string/"/>
    <id>http://ysocks.gitee.io/2020/08/21/find-file-include-same-string/</id>
    <published>2020-08-21T01:07:17.000Z</published>
    <updated>2020-08-22T12:33:48.483Z</updated>
    
    <content type="html"><![CDATA[<p>想在整个文件夹下面查找包含字符串 “getAll”并且类型是.js的文件</p><p>终端命令：<br><code>find ./ -name &quot;*.js&quot; | xargs grep &quot;getAll&quot; -l</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想在整个文件夹下面查找包含字符串 “getAll”并且类型是.js的文件&lt;/p&gt;
&lt;p&gt;终端命令：&lt;br&gt;&lt;code&gt;find ./ -name &amp;quot;*.js&amp;quot; | xargs grep &amp;quot;getAll&amp;quot; -l&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>brew 安装zookeeper 3.4.14</title>
    <link href="http://ysocks.gitee.io/2020/07/29/brew_install_zookeeper_3_4_14/"/>
    <id>http://ysocks.gitee.io/2020/07/29/brew_install_zookeeper_3_4_14/</id>
    <published>2020-07-29T02:15:49.000Z</published>
    <updated>2020-07-29T02:18:39.512Z</updated>
    
    <content type="html"><![CDATA[<p>brew 安装zookeeper 3.4.14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># force install zookeeper first</span><br><span class="line">brew install https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;6d8197bbb5f77e62d51041a3ae552ce2f8ff1344&#x2F;Formula&#x2F;zookeeper.rb</span><br><span class="line"></span><br><span class="line"># then force install kafka compatible with zookeeper 3.4.14</span><br><span class="line">brew install --ignore-dependencies https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;6d8197bbb5f77e62d51041a3ae552ce2f8ff1344&#x2F;Formula&#x2F;kafka.rb</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;brew 安装zookeeper 3.4.14&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MacOS brew 安装 consul</title>
    <link href="http://ysocks.gitee.io/2020/07/28/MacOS-brew-install-consul/"/>
    <id>http://ysocks.gitee.io/2020/07/28/MacOS-brew-install-consul/</id>
    <published>2020-07-28T15:34:00.000Z</published>
    <updated>2020-07-28T15:39:13.759Z</updated>
    
    <content type="html"><![CDATA[<p>安装consul</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install consul</span><br></pre></td></tr></table></figure><p>配置consul：<br><code>vim /usr/local/opt/consul/homebrew.mxcl.consul.plist</code></p><p>修改 ProgramArguments 部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;consul&#x2F;bin&#x2F;consul&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;agent&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-server&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-bootstrap&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-advertise&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;127.0.0.1&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-data-dir&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;.&#x2F;data&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-ui&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure><p>然后启动服务：<br><code>brew services start consul</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装consul&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code
      
    
    </summary>
    
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>MacOS zsh history命令显示操作时间</title>
    <link href="http://ysocks.gitee.io/2020/07/07/Mac-zsh-history-show-time/"/>
    <id>http://ysocks.gitee.io/2020/07/07/Mac-zsh-history-show-time/</id>
    <published>2020-07-07T05:41:00.000Z</published>
    <updated>2020-07-07T05:43:10.149Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -E</span></span><br><span class="line">    1   2.12.2013 14:19  cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -i</span></span><br><span class="line">    1  2013-12-02 14:19  history -E</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -D</span></span><br><span class="line">    1  0:00  history -E</span><br><span class="line">    2  0:00  history -I</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="mac" scheme="http://ysocks.gitee.io/categories/mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac GitBook安装和使用</title>
    <link href="http://ysocks.gitee.io/2020/06/20/Install-gitbook-on-mac/"/>
    <id>http://ysocks.gitee.io/2020/06/20/Install-gitbook-on-mac/</id>
    <published>2020-06-20T13:39:00.000Z</published>
    <updated>2020-06-20T13:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><p>安装npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"> &#x2F;&#x2F; 检查npm是否安装成功</span><br><span class="line"> npm -v</span><br><span class="line"> &#x2F;&#x2F; 检查node是否存在</span><br><span class="line"> node -v</span><br></pre></td></tr></table></figure></li><li><p>安装GitBook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gitbook是在npm环境下安装的，所以前提得先安装好npm。</span><br><span class="line">&#x2F;&#x2F; 安装Gitbook命令</span><br><span class="line">sudo npm install -g gitbook-cli</span><br><span class="line">&#x2F;&#x2F; 检查是否安装成功</span><br><span class="line">gitbook -v</span><br></pre></td></tr></table></figure></li><li><p>安装Gitbook Editor客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官网下载地址：https:&#x2F;&#x2F;www.gitbook.com&#x2F;editor</span><br><span class="line">用它辅助写文档很好用，可以登录从GitBook下载Book进行修改提交（我试过直接https进行拉取出错，后来直接云端下载同步到本地才能进行push操作）</span><br><span class="line">不过没有生成静态Html（_book那个文件夹），还需cd 命令进入book所在文件使用gitbook build这条命令进行生成。</span><br><span class="line">不过Gitbook网站里支持阅读和下载。</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>不能使用 npm install gitbook -g 命令安装，因为使用命令gitbook的时候会出现问题。</li><li>安装的命令前需要加入sudo,因为可能会找不到npm的 /usr/local/bin/路径。</li><li>使用gitbook -v命令检查时可能会不出现版本号，但其实是安装好了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装npm&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="gitbook" scheme="http://ysocks.gitee.io/categories/gitbook/"/>
    
    
      <category term="gitbook" scheme="http://ysocks.gitee.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>grep搜索子目录中包含某字符串的特定文件</title>
    <link href="http://ysocks.gitee.io/2020/06/04/grep-string-from-folder/"/>
    <id>http://ysocks.gitee.io/2020/06/04/grep-string-from-folder/</id>
    <published>2020-06-04T02:54:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>grep -n &quot;str&quot; -r ./</code></p><p>这是查找当前目录下以及下辖子目录下所有包含str字符串的文件,会列出文件名.以及该行的内容.以及行号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;grep -n &amp;quot;str&amp;quot; -r ./&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是查找当前目录下以及下辖子目录下所有包含str字符串的文件,会列出文件名.以及该行的内容.以及行号&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://ysocks.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql 分页</title>
    <link href="http://ysocks.gitee.io/2020/05/22/mysql-page/"/>
    <id>http://ysocks.gitee.io/2020/05/22/mysql-page/</id>
    <published>2020-05-22T14:25:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前借助mysql-plus分页，由于表数据越来越大 导致分页效率越来越低</p><p>改为用id来分页，效果明显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">A.* </span><br><span class="line">FROM</span><br><span class="line">time_machine_cmd A  </span><br><span class="line">JOIN </span><br><span class="line">    ( SELECT id FROM time_machine_cmd LIMIT 3000, 10 ) B</span><br><span class="line">    ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前借助mysql-plus分页，由于表数据越来越大 导致分页效率越来越低&lt;/p&gt;
&lt;p&gt;改为用id来分页，效果明显&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何重新安装 macOS 系统</title>
    <link href="http://ysocks.gitee.io/2020/05/16/how-to-reinstall-macos/"/>
    <id>http://ysocks.gitee.io/2020/05/16/how-to-reinstall-macos/</id>
    <published>2020-05-16T09:20:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家可能都知道了，重装 macOS 系统可以在重启 Mac 时按住 <strong>⌘-R</strong> 键。</p><a id="more"></a><p>R 应该就是「Recovery」的意思</p><p>当出现「实用工具」窗口时松开，然后选择「重新安装 macOS」。<br>这样会重新安装你现在 Mac 上的 macOS 版本。</p><p>这也是我们重新安装 macOS 系统最常用的方法。但除此之外还有别的方式。</p><p><strong>option-⌘-R</strong></p><p>重启 Mac 时按住 ⌘-R 键，当看到旋转地球出现时松开。</p><p>这样会升级到与你的 Mac 兼容的最新版 macOS。</p><p><strong>shift-option-⌘-R</strong></p><p>当看到旋转地球出现时松开。</p><p>这样会开始安装你电脑出场时的那个系统版本。</p><p>举个例子可能更好理解这三种的区别：</p><p>比如假设我的全新 MacBook Pro 购买时当初是 10.12.4，现在的版本是 10.13.1，然后现在的最新版本已经是 10.14.5。</p><p>如果我用 <strong>⌘-R</strong> 来重装，得到的就是升级之前一样的 10.13 的最新版，也就是10.13.4。</p><p>如果我用 <strong>option-⌘-R</strong> 来重装，得到的就是现在官方的最新版 10.14.5。</p><p>如果我用 <strong>shift-option-⌘-R</strong> 来重装，得到的就是我当初购买时候的 10.12.4。</p><p>以上方法重新安装系统都不会删除你原来的的文件和设置。</p><p>如果你想要在重装时先格式化你的磁盘，可以在 macOS 实用工具窗口选择「磁盘工具」，然后抹掉磁盘，再执行重新安装操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家可能都知道了，重装 macOS 系统可以在重启 Mac 时按住 &lt;strong&gt;⌘-R&lt;/strong&gt; 键。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac 10.14.6安装 brew</title>
    <link href="http://ysocks.gitee.io/2020/05/14/install-brew-on-mac/"/>
    <id>http://ysocks.gitee.io/2020/05/14/install-brew-on-mac/</id>
    <published>2020-05-14T06:27:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 10.14.6安装 brew</p><p>一、获取 install 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install &gt;&gt; brew_install</span><br></pre></td></tr></table></figure><a id="more"></a><p>二、更改脚本中的资源链接<br>替换<br><code>BREW_REPO = “https://github.com/Homebrew/brew“.freeze</code><br>为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BREW_REPO &#x3D; &quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git&quot;.freeze</span><br></pre></td></tr></table></figure><p>三、运行脚本</p><p><code>/usr/bin/ruby brew_install</code></p><p>四、下载homebrew-core</p><p>到下载homebrew-core这步会失败<br>失败后运行以下命令clone git库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core --depth&#x3D;1</span><br></pre></td></tr></table></figure><p>五、检查安装是否成功</p><p><code>brew doctor</code></p><p>六、添加清华大学镜像源</p><pre><code>echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&apos;&gt;&gt;   ~/.bash_profile</code></pre><p>使其生效<br><code>source ~/.bash_profile</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 10.14.6安装 brew&lt;/p&gt;
&lt;p&gt;一、获取 install 文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fsSL https:&amp;#x2F;&amp;#x2F;raw.githubusercontent.com&amp;#x2F;Homebrew&amp;#x2F;install&amp;#x2F;master&amp;#x2F;install &amp;gt;&amp;gt; brew_install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>常见 MySQL 的慢查询优化方式</title>
    <link href="http://ysocks.gitee.io/2020/05/13/%E5%B8%B8%E8%A7%81-MySQL-%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://ysocks.gitee.io/2020/05/13/%E5%B8%B8%E8%A7%81-MySQL-%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-13T02:38:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>慢查询日志概念</p><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。</p><a id="more"></a><p>默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>慢查询日志相关参数</p><p>MySQL 慢查询的相关参数解释：</p><ul><li>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><p>一，第一步.开启mysql慢查询<br>方式一：<br>修改配置文件  在 my.ini 增加几行:  主要是慢查询的定义时间，以及慢查询log日志记录（ slow_query_log）<br>方法二：通过MySQL数据库开启慢查询:</p><p>二，分析慢查询日志<br>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句<br>例如：执行</p><p><code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code><br>得到如下结果：显示结果分析：<br><code>table |  type | possible_keys | key |key_len  | ref | rows | Extra</code><br>EXPLAIN列的解释:</p><ul><li>table   显示这一行的数据是关于哪张表的           </li><li>type    这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</li><li>rows   显示需要扫描行数</li><li>key     使用的索引</li></ul><p>三，常见的慢查询优化</p><p>（1）索引没起作用的情况</p><ul><li>使用LIKE关键字的查询语句<br>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</li><li>使用多列索引的查询语句<br>MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</li></ul><p>（2）优化数据库结构<br>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ul><li>将字段很多的表分解成多个表<br>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li><li>增加中间表<br>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</li></ul><p>（3）分解关联查询<br>将一个大的查询分解为多个小查询是很有必要的。<br>很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag </span><br><span class="line">JOIN tag_post ON tag_id &#x3D; tag.id</span><br><span class="line">JOIN post ON tag_post.post_id &#x3D; post.id</span><br><span class="line">WHERE tag.tag &#x3D; &#39;mysql&#39;;</span><br></pre></td></tr></table></figure><p>分解为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag WHERE tag &#x3D; &#39;mysql&#39;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id &#x3D; 1234;</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456,567);</span><br></pre></td></tr></table></figure><p>（4）优化LIMIT分页<br> 在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p> 一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p><p>优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p> 对于下面的查询：</p><p>  <code>select id,title from collect limit 90000,10;</code></p><p>该语句存在的最大问题在于limit M,N中偏移量M太大（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。</p><p> 如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次 查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</p><p>方法一：虑筛选字段（title）上加索引<br>title字段加索引  （此效率如何未加验证）</p><p>方法二：先查询出主键id值<br><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</p><p>方法三：“关延迟联”<br>如果这个表非常大，那么这个查询可以改写成如下的方式：<br>  <code>select news.id, news.description from news   inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>这里的“关延迟联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><p>方法四：建立复合索引 acct_id和create_time<br><code>select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;慢查询日志概念&lt;/p&gt;
&lt;p&gt;MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git merge –squash介绍</title>
    <link href="http://ysocks.gitee.io/2020/05/09/git-merge-squash/"/>
    <id>http://ysocks.gitee.io/2020/05/09/git-merge-squash/</id>
    <published>2020-05-09T13:07:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git相对于CVS和SVN的一大好处就是merge非常方便，只要指出branch的名字就好了，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge another</span><br><span class="line">$ git checkout another</span><br><span class="line"># modify, commit, modify, commit ...</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge another</span><br></pre></td></tr></table></figure><a id="more"></a><p>但是，操作方便并不意味着这样操作就是合理的，在某些情况下，我们应该优先选择使用<code>--squash</code>选项，如下：</p><pre><code>$ git merge --squash another$ git commit -m &quot;message here&quot;</code></pre><p><code>--squash</code>选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来。</p><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p><p>如果在开发分支上提交非常随意，甚至写成微博体，那么一定要使用<code>--squash</code>选项。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p><p>只有在开发分支上每个commit都有其独自存在的意义，并且能够编译通过的情况下（能够通过测试就更完美了），才应该选择缺省的合并方式来保留commit历史。</p><p>转自：<a href="https://www.cnblogs.com/lookphp/p/5799533.html" target="_blank" rel="noopener">git merge –squash介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git相对于CVS和SVN的一大好处就是merge非常方便，只要指出branch的名字就好了，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge another&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout another&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modify, commit, modify, commit ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge another&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac下设置 sublime Text3 在同一个窗口打开多个文件</title>
    <link href="http://ysocks.gitee.io/2020/05/07/open-multi-file-in-sublime/"/>
    <id>http://ysocks.gitee.io/2020/05/07/open-multi-file-in-sublime/</id>
    <published>2020-05-07T12:21:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开Sublime Text软件</p><p>点击左上角的<code>Sublime Text ---&gt; Preferences ---&gt; Settings－user</code></p><p>添加 <code>&quot;open_files_in_new_window&quot;:false</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开Sublime Text软件&lt;/p&gt;
&lt;p&gt;点击左上角的&lt;code&gt;Sublime Text ---&amp;gt; Preferences ---&amp;gt; Settings－user&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;&amp;quot;open_files_in_new
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>git撤销commit 并保存之前的修改</title>
    <link href="http://ysocks.gitee.io/2020/05/07/git-revert-commit-keep-modify/"/>
    <id>http://ysocks.gitee.io/2020/05/07/git-revert-commit-keep-modify/</id>
    <published>2020-05-07T05:31:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>写完代码后，我们一般这样<br><code>git add .</code> //添加所有文件<br><code>git commit -m &quot;本功能全部完成&quot;</code></p><a id="more"></a><p>执行完commit后，想撤回commit，怎么办？</p><p>这样凉拌:</p><p><code>git reset --soft HEAD^</code></p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>说一下个人理解：</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><p>至于这几个参数：</p><p><code>--mixed</code></p><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p><p><code>--soft</code> </p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><p><code>--hard</code></p><p>删除工作空间改动代码，撤销commit，撤销git add .</p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><p>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：</p><p><code>git commit --amend</code></p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写完代码后，我们一般这样&lt;br&gt;&lt;code&gt;git add .&lt;/code&gt; //添加所有文件&lt;br&gt;&lt;code&gt;git commit -m &amp;quot;本功能全部完成&amp;quot;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git-stash 搁置修改</title>
    <link href="http://ysocks.gitee.io/2020/04/22/git-stash/"/>
    <id>http://ysocks.gitee.io/2020/04/22/git-stash/</id>
    <published>2020-04-22T11:18:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候写了一半的JAVA代码，都还不能编译通过的，就被叫去改另一个分支的bug了。  </p><a id="more"></a><p>在new分支上的时候在命令行输入：</p><p><code>git stash</code></p><p>或者</p><p><code>git stash save  “修改的信息&quot;</code></p><p>这样以后你的代码就回到自己上一个commit了，直接git stash的话git stash的栈会直接给你一个hash值作为版本的说明，如果用git stash save “修改的信息”，git stash的栈会把你填写的“修改的信息”作为版本的说明。</p><p>接下来你回到old分支修改代码完成，你又再回到new分支，输入：</p><p><code>git stash pop</code><br>或者<br><code>git stash list</code><br><code>git stash apply stash@{0}</code></p><p>就可以回到保存的版本了。</p><p><code>git stash pop</code>的作用是将<code>git stash</code>栈中最后一个版本取出来，<code>git stash apply stash@{0}</code>的作用是可以指定栈中的一个版本，通过<code>git stash list</code>可以看到所有的版本信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: On order-master-bugfix: 22222   </span><br><span class="line">stash@&#123;1&#125;: On order-master-bugfix: 22222</span><br></pre></td></tr></table></figure><p>然后你可以选择一个你需要的版本执行：</p><p><code>git stash apply stash@{0}</code></p><p>这时候你搁置的代码就回来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候写了一半的JAVA代码，都还不能编译通过的，就被叫去改另一个分支的bug了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Collectors</title>
    <link href="http://ysocks.gitee.io/2020/04/16/Collectors/"/>
    <id>http://ysocks.gitee.io/2020/04/16/Collectors/</id>
    <published>2020-04-16T08:43:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="./2020/04/15/Stream-API/">第二天</a>，你已经学习了Stream API能够让你以声明式的方式帮助你处理集合。我们看到<code>collect</code>是一个将管道流的结果集到一个<code>list</code>中的结束操作。<code>collect</code>是一个将数据流缩减为一个值的归约操作。这个值可以是集合、映射，或者一个值对象。你可以使用<code>collect</code>达到以下目的：</p><a id="more"></a><ol><li><p><strong>将数据流缩减为一个单一值：</strong>一个流执行后的结果能够被缩减为一个单一的值。单一的值可以是一个<code>Collection</code>，或者像int、double等的数值，再或者是一个用户自定义的值对象。</p></li><li><p><strong>将一个数据流中的元素进行分组：</strong>根据任务类型将流中所有的任务进行分组。这将产生一个<code>Map&lt;TaskType, List&lt;Task&gt;&gt;</code>的结果，其中每个实体包含一个任务类型以及与它相关的任务。你也可以使用除了列表以外的任何其他的集合。如果你不需要与一任务类型相关的所有的任务，你可以选择产生一个<code>Map&lt;TaskType, Task&gt;</code>。这是一个能够根据任务类型对任务进行分类并获取每类任务中第一个任务的例子。</p></li><li><p><strong>分割一个流中的元素：</strong>你可以将一个流分割为两组——比如将任务分割为要做和已经做完的任务。</p></li></ol><h2 id="Collector实际应用"><a href="#Collector实际应用" class="headerlink" title="Collector实际应用"></a>Collector实际应用</h2><p>为了感受到<code>Collector</code>的威力，让我们来看一下我们要根据任务类型来对任务进行分类的例子。在Java8中，我们可以通过编写如下的代码达到将任务根据类型分组的目的。<strong>请参考<a href="./03-streams.md">第二天</a>的博文，也就是我们讨论的在这一系列文章中我们将使用的任务域。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; groupTasksByType(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(Collectors.groupingBy(task -&gt; task.getType()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用了定义在辅助类<code>Collectors</code>中的<code>groupingBy</code>收集器。它创建了一个映射，其中<code>TaskType</code>是它的键，而包含了所有拥有相同<code>TaskType</code>的任务的列表是它的值。为了在Java7中达到相同的效果，你需要编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">    Map&lt;TaskType, List&lt;Task&gt;&gt; allTasksByType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">        List&lt;Task&gt; existingTasksByType = allTasksByType.get(task.getType());</span><br><span class="line">        <span class="keyword">if</span> (existingTasksByType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Task&gt; tasksByType = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tasksByType.add(task);</span><br><span class="line">            allTasksByType.put(task.getType(), tasksByType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            existingTasksByType.add(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TaskType, List&lt;Task&gt;&gt; entry : allTasksByType.entrySet()) &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s =&gt;&gt; %s"</span>, entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收集器：常用的规约操作"><a href="#收集器：常用的规约操作" class="headerlink" title="收集器：常用的规约操作"></a>收集器：常用的规约操作</h2><p><code>Collectors</code>辅助类提供了大量的静态辅助方法来创建收集器为常见的使用场景服务，像将元素收集到一个集合中、分组和分割元素，或者根据不同的标准来概述元素。我们将在这篇博文中涵盖大部分常见的<code>Collector</code>。</p><h2 id="缩减为一个值"><a href="#缩减为一个值" class="headerlink" title="缩减为一个值"></a>缩减为一个值</h2><p>正如上面讨论的，收集器可以被用来收集流的输出到一个集合，或者产生一个单一的值。</p><h3 id="将数据收集进一个列表"><a href="#将数据收集进一个列表" class="headerlink" title="将数据收集进一个列表"></a>将数据收集进一个列表</h3><p>让我们编写我们的第一个测试用例——给定一个任务列表，我们想将他们的标题收集进一个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2_ReduceValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toList</code>收集器使用了列表的<code>add</code>方法来向结果列表中添加元素。<code>toList</code>收集器使用了<code>ArrayList</code>作为列表的实现。</p><h3 id="将数据收集进一个集合"><a href="#将数据收集进一个集合" class="headerlink" title="将数据收集进一个集合"></a>将数据收集进一个集合</h3><p>如果我们想要确保返回的标题都是唯一的，并且我们不在乎元素的顺序，那么我们可以使用<code>toSet</code>收集器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">uniqueTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(toSet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toSet</code>方法使用了<code>HashSet</code>作为集合的实现来存储结果集。</p><h3 id="将数据收集进一个映射"><a href="#将数据收集进一个映射" class="headerlink" title="将数据收集进一个映射"></a>将数据收集进一个映射</h3><p>你可以使用<code>toMap</code>收集器将一个流转换为一个映射。<code>toMap</code>收集器需要两个映射方法来获得映射的键和值。在下面展示的代码中，<code>Task::getTitle</code>是接收一个任务并产生一个只包含该任务标题的键的<code>Function</code>。<strong>task -&gt; task</strong>是一个用来返回任务本身的lambda表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, task -&gt; task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过使用<code>Function</code>接口中的默认方法<code>identity</code>来改进上面展示的代码，如下所示，这样可以让代码更加简洁，并更好地传达开发者的意图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.function.Function.identity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从一个流中创建映射的代码会在存在重复的键时抛出异常。你将会得到一个类似下面的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Duplicate key Task&#123;title&#x3D;&#39;Read Version Control with Git book&#39;, type&#x3D;READING&#125;</span><br><span class="line">at java.util.stream.Collectors.lambda$throwingMerger$105(Collectors.java:133)</span><br></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的另一个变体来处理重复问题，它允许我们指定一个合并方法。这个合并方法允许用户他们指定想如何处理多个值关联到同一个键的冲突。在下面展示的代码中，我们只是使用了新的值，当然你也可以编写一个智能的算法来处理冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap_duplicates</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的第三个变体来指定其他的映射实现。这需要你指定将用来存储结果的<code>Map</code>和<code>Supplier</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, Task&gt; collectToMap(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">    return tasks.stream().collect(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2, LinkedHashMap::new));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于<code>toMap</code>收集器，也有<code>toConcurrentMap</code>收集器，它产生一个<code>ConcurrentMap</code>而不是<code>HashMap</code>。</p><h3 id="使用其它的收集器"><a href="#使用其它的收集器" class="headerlink" title="使用其它的收集器"></a>使用其它的收集器</h3><p>像<code>toList</code>和<code>toSet</code>这类特定的收集器不允许你指定内部的列表或者集合实现。当你想要将结果收集到其它类型的集合中时，你可以像下面这样使用<code>toCollection</code>收集器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static LinkedHashSet&lt;Task&gt; collectToLinkedHaskSet(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">  return tasks.stream().collect(toCollection(LinkedHashSet::new));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到拥有最长标题的任务"><a href="#找到拥有最长标题的任务" class="headerlink" title="找到拥有最长标题的任务"></a>找到拥有最长标题的任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">taskWithLongestTitle</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(collectingAndThen(maxBy((t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length()), Optional::get));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计标签的总数"><a href="#统计标签的总数" class="headerlink" title="统计标签的总数"></a>统计标签的总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalTagCount</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(summingInt(task -&gt; task.getTags().size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成任务标题的概述"><a href="#生成任务标题的概述" class="headerlink" title="生成任务标题的概述"></a>生成任务标题的概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">titleSummary</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="string">";"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分类收集器"><a href="#分类收集器" class="headerlink" title="分类收集器"></a>分类收集器</h2><p>收集器最常见的使用场景之一是对元素进行分类。让我来看一下不同的例子来理解我们如何进行分类。</p><h3 id="例子1：根据类型对任务分类"><a href="#例子1：根据类型对任务分类" class="headerlink" title="例子1：根据类型对任务分类"></a>例子1：根据类型对任务分类</h3><p>我们看一下下面展示的例子，我们想要根据<code>TaskType</code>来对所有的任务进行分类。我们可以通过使用<code>Collectors</code>辅助类中的<code>groupingBy</code>方法来轻易地进行该项任务。你可以通过使用方法引用和静态导入来使它更加高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.groupingBy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; groupTasksByType(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">       <span class="keyword">return</span> tasks.stream().collect(groupingBy(Task::getType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将会产生如下的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;CODING&#x3D;[Task&#123;title&#x3D;&#39;Write a mobile application to store my tasks&#39;, type&#x3D;CODING, createdOn&#x3D;2015-07-03&#125;], WRITING&#x3D;[Task&#123;title&#x3D;&#39;Write a blog on Java 8 Streams&#39;, type&#x3D;WRITING, createdOn&#x3D;2015-07-04&#125;], READING&#x3D;[Task&#123;title&#x3D;&#39;Read Version Control with Git book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-01&#125;, Task&#123;title&#x3D;&#39;Read Java 8 Lambdas book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-02&#125;, Task&#123;title&#x3D;&#39;Read Domain Driven Design book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-05&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：根据标签分类"><a href="#例子2：根据标签分类" class="headerlink" title="例子2：根据标签分类"></a>例子2：根据标签分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;Task&gt;&gt; groupingByTag(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().</span><br><span class="line">                flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="keyword">new</span> TaskTag(tag, task))).</span><br><span class="line">                collect(groupingBy(TaskTag::getTag, mapping(TaskTag::getTask,toList())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTag</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String tag;</span><br><span class="line">        <span class="keyword">final</span> Task task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TaskTag</span><span class="params">(String tag, Task task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="例子3：根据标签和数量对任务分类"><a href="#例子3：根据标签和数量对任务分类" class="headerlink" title="例子3：根据标签和数量对任务分类"></a>例子3：根据标签和数量对任务分类</h3><p>将分类器和收集器结合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Long&gt; <span class="title">tagsAndCount</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().</span><br><span class="line">        flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="keyword">new</span> TaskTag(tag, task))).</span><br><span class="line">        collect(groupingBy(TaskTag::getTag, counting()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="例子4：根据任务类型和创建日期分类"><a href="#例子4：根据任务类型和创建日期分类" class="headerlink" title="例子4：根据任务类型和创建日期分类"></a>例子4：根据任务类型和创建日期分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, Map&lt;LocalDate, List&lt;Task&gt;&gt;&gt; groupTasksByTypeAndCreationDate(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().collect(groupingBy(Task::getType, groupingBy(Task::getCreatedOn)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>很多时候你想根据一个断言来将一个数据集分割成两个数据集。举例来说，我们可以通过定义一个将任务分割为两组的分割方法来将任务分割成两组，一组是在今天之前已经到期的，另一组是其他的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Boolean, List&lt;Task&gt;&gt; partitionOldAndFutureTasks(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(partitioningBy(task -&gt; task.getDueOn().isAfter(LocalDate.now())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成统计信息"><a href="#生成统计信息" class="headerlink" title="生成统计信息"></a>生成统计信息</h2><p>另一组非常有用的收集器是用来产生统计信息的收集器。这能够在像<code>int</code>、<code>double</code>和<code>long</code>这样的原始数据类型上起到作用；并且能被用来生成像下面这样的统计信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics summaryStatistics = tasks.stream().map(Task::getTitle).collect(summarizingInt(String::length));</span><br><span class="line">System.out.println(summaryStatistics.getAverage()); <span class="comment">//32.4</span></span><br><span class="line">System.out.println(summaryStatistics.getCount()); <span class="comment">//5</span></span><br><span class="line">System.out.println(summaryStatistics.getMax()); <span class="comment">//44</span></span><br><span class="line">System.out.println(summaryStatistics.getMin()); <span class="comment">//24</span></span><br><span class="line">System.out.println(summaryStatistics.getSum()); <span class="comment">//162</span></span><br></pre></td></tr></table></figure><p>也有其它的变种形式，像针对其它原生类型的<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>。</p><p>你也可以通过使用<code>combine</code>操作来将一个<code>IntSummaryStatistics</code>与另一个组合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstSummaryStatistics.combine(secondSummaryStatistics);</span><br><span class="line">System.out.println(firstSummaryStatistics)</span><br></pre></td></tr></table></figure><h2 id="连接所有的标题"><a href="#连接所有的标题" class="headerlink" title="连接所有的标题"></a>连接所有的标题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">allTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="string">", "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个定制的收集器"><a href="#编写一个定制的收集器" class="headerlink" title="编写一个定制的收集器"></a>编写一个定制的收集器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.HashMultiset;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Multiset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultisetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Multiset</span>&lt;<span class="title">T</span>&gt;, <span class="title">Multiset</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Multiset&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> HashMultiset::create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Multiset&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (set, e) -&gt; set.add(e, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Multiset&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Multiset&lt;T&gt;, Multiset&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Multiset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultisetCollectorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">"shekhar"</span>, <span class="string">"rahul"</span>, <span class="string">"shekhar"</span>);</span><br><span class="line">        Multiset&lt;String&gt; set = names.stream().collect(<span class="keyword">new</span> MultisetCollector&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        set.forEach(str -&gt; System.out.println(str + <span class="string">":"</span> + set.count(str)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java8中的字数统计"><a href="#Java8中的字数统计" class="headerlink" title="Java8中的字数统计"></a>Java8中的字数统计</h2><p>我们将通过使用流和收集器在Java8中编写有名的字数统计样例来结束这一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wordCount</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Map&lt;String, Long&gt; wordCount = Files.lines(path)</span><br><span class="line">            .parallel()</span><br><span class="line">            .flatMap(line -&gt; Arrays.stream(line.trim().split(<span class="string">"\\s"</span>)))</span><br><span class="line">            .map(word -&gt; word.replaceAll(<span class="string">"[^a-zA-Z]"</span>, <span class="string">""</span>).toLowerCase().trim())</span><br><span class="line">            .filter(word -&gt; word.length() &gt; <span class="number">0</span>)</span><br><span class="line">            .map(word -&gt; <span class="keyword">new</span> SimpleEntry&lt;&gt;(word, <span class="number">1</span>))</span><br><span class="line">            .collect(groupingBy(SimpleEntry::getKey, counting()));</span><br><span class="line">    wordCount.forEach((k, v) -&gt; System.out.println(String.format(<span class="string">"%s ==&gt;&gt; %d"</span>, k, v)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;./2020/04/15/Stream-API/&quot;&gt;第二天&lt;/a&gt;，你已经学习了Stream API能够让你以声明式的方式帮助你处理集合。我们看到&lt;code&gt;collect&lt;/code&gt;是一个将管道流的结果集到一个&lt;code&gt;list&lt;/code&gt;中的结束操作。&lt;code&gt;collect&lt;/code&gt;是一个将数据流缩减为一个值的归约操作。这个值可以是集合、映射，或者一个值对象。你可以使用&lt;code&gt;collect&lt;/code&gt;达到以下目的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/categories/java/"/>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Stream API</title>
    <link href="http://ysocks.gitee.io/2020/04/15/Stream-API/"/>
    <id>http://ysocks.gitee.io/2020/04/15/Stream-API/</id>
    <published>2020-04-15T05:29:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="./2020/04/15/java8-lambda/">第二章</a>中，我们通过学习lambda表达式，了解了如何能够在不创建额外类的情况下传递行为来帮助我们编写出简洁精练的代码。lambda表达式是一种通过使用函数式接口让开发者能够快速表达他们的想法的语言概念。设计API的时候将lambda，也就是那些使用了函数式接口的流畅的API（我们在<a href="./02-lambdas.md#lambda表达式是如何在Java8中工作的">lambdas章节</a>中讨论过它们）记在脑子中，我们才能真正体验到lambda的强大。  </p><a id="more"></a><p>在Java8中引进的Stream API是使用lambda的API之一。就像SQL如何帮助你在数据库中形象地查询数据，Stream在Java集合计算上提供了一个形象的声明式的高层抽象来表示计算。形象的意思是指开发者只要写他们想写的，而不是关注他们该如何来写。在这一章中，我们将讨论对一个新的数据处理API的需求、<code>Collection</code>和<code>Stream</code>的区别，和如何在你的应用中使用Stream API。</p><blockquote><p>这一节的代码在<a href="https://github.com/shekhargulati/java8-the-missing-tutorial/tree/master/code/src/main/java/com/shekhargulati/java8_tutorial/ch03" target="_blank" rel="noopener">ch03</a>包中</p></blockquote><h2 id="为什么我们需要一个新的数据处理抽象"><a href="#为什么我们需要一个新的数据处理抽象" class="headerlink" title="为什么我们需要一个新的数据处理抽象"></a>为什么我们需要一个新的数据处理抽象</h2><p>在我的观点中，主要有两个原因：</p><ol><li><code>Collection</code> API没有提供高层的概念来查询数据，所以开发者被迫为琐碎的工作编写很多重复的代码。</li><li>对<code>Collection</code>的并行操作在语言支持方面受到了限制。只能让开发者用Java的并发机制来让数据并行处理快速而有效。</li></ol><h2 id="在Java8之前的数据处理"><a href="#在Java8之前的数据处理" class="headerlink" title="在Java8之前的数据处理"></a>在Java8之前的数据处理</h2><p>看下面的代码并试图说出它的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1_Java7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">        List&lt;Task&gt; readingTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.getType() == TaskType.READING) &#123;</span><br><span class="line">                readingTasks.add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(readingTasks, <span class="keyword">new</span> Comparator&lt;Task&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Task t1, Task t2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> t1.getTitle().length() - t2.getTitle().length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Task readingTask : readingTasks) &#123;</span><br><span class="line">            System.out.println(readingTask.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将阅读任务按照它们标题的长度进行排序后输出。Java7的开发者成天要写这类的代码。为了写一个这样简单的程序，我们编写了15行代码。上面提到的代码的最大问题不是开发者要编写的代码的数量，而是它丢失了开发者的意图，也就是过滤阅读任务，根据标题长度排序，和转换成字符串列表。</p><h2 id="Java8中的数据处理"><a href="#Java8中的数据处理" class="headerlink" title="Java8中的数据处理"></a>Java8中的数据处理</h2><p>如下所示，上述的代码可以通过Java8的<code>Stream</code> API简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1_Stream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; readingTasks = tasks.stream()</span><br><span class="line">                .filter(task -&gt; task.getType() == TaskType.READING)</span><br><span class="line">                .sorted((t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length())</span><br><span class="line">                .map(Task::getTitle)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        readingTasks.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码构建了一个由许多流式操作组成的管道流，下面对其一一讲解。</p><ul><li><strong>stream()</strong>: 通过在一个原始的集合上调用<code>stream</code>方法来创建一个流式管道流，而<code>tasks</code>就是<code>List&lt;Task&gt;</code>类型的。</li><li><strong>filter(Predicate<T>)</strong>: 这个操作从流中抽取符合断言的判定条件的元素。一旦你有了一个数据流，你可以在其上不调用或者多次调用中间操作。lambda表达式<code>task -&gt; task.getType() == TaskType.READING</code>定义了一个断言来过滤所有的阅读任务。该lambda表达式的类型为<code>java.util.function.Predicate&lt;Task&gt;</code>。</li><li><strong>sorted(Comparator<T>)</strong>:这个操作返回一个根据由lambda表达式定义的比较器进行排序后的元素组成的数据流。在上面的例子中，这个比较器是<code>(t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length()</code> 。</li><li><strong>map(Function&lt;T,R&gt;)</strong>: 这个操作对数据流中的元素都进行<code>Fuction&lt;T,R&gt;</code>的操作，并返回新的数据流。</li><li><strong>collect(toList())</strong>:这个操作将经过各种操作处理后的数据流中的元素收集到一个列表中。</li></ul><h3 id="为什么Java8编写的代码更好"><a href="#为什么Java8编写的代码更好" class="headerlink" title="为什么Java8编写的代码更好"></a>为什么Java8编写的代码更好</h3><p>我认为Java8的代码更好的理由如下：</p><ol><li>Java8的代码清晰地展现出开发者的意图，如过滤、排序等。</li><li>开发者通过Stream API的形式能够在一个高层的抽象上来表现出他们想要做什么，而不是他们如何来作。</li><li>Stream API为数据处理提供了一个统一的语言。现在当程序员讨论到数据处理时，它们将会有共同的词汇。当两个开发者谈论到<code>filter</code>方法时，你可以肯定他们都在使用一个数据过滤操作。</li><li>处理数据时不需要重复的代码。用户不需要写专门的<code>for</code>循环，也不用创建临时集合来存储数据。所有的工作都可以通过Stream API来完成。</li><li>Stream不会修改你原来的集合——它们是免于变化的。</li></ol><h2 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h2><p>Stream是一些数据上的抽象视图。举例来说，Stream可以是列表、文件中的每行数据，或者其他任意元素的序列的一个视图。Stream API提供了可以连续执行，或者并行执行的操作集合。<strong><em>开发者需要记住的是Stream是一个高层的抽象，而不是一个数据结构。Stream不会存储你的数据。</em></strong> Stream本身是<strong>懒惰</strong>的，只有使用到它们时才会开始计算。这使我们能够产生无数的数据流。在Java8中，你能够像下面一样编写一个Stream来产生无数的唯一标识码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; uuidStream &#x3D; Stream.generate(() -&gt; UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Stream的接口中，有很多像<code>of</code>、<code>generate</code>和<code>iterate</code>一样的静态工厂方法，它们可以用来创建Stream的实例。上面展示的<code>generate</code>方法以<code>Supplier</code>为参数。<code>Supplier</code>是一个函数式接口，用来描述一个不需要参数并返回一个值的函数。我们传递给<code>generate</code>方法一个供应者，那么当调用的时候，就能产生一个唯一标识码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; uuids = () -&gt; UUID.randomUUID().toString()</span><br></pre></td></tr></table></figure><p>如果我们运行上面的代码，那么什么都不会发生，因为Stream是懒惰的，它没有被使用之前，什么计算都不会进行。如果我们将代码更新成下面这样，我们将会看到在控制台上输出UUID。该程序将会不断运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; uuidStream = Stream.generate(() -&gt; UUID.randomUUID().toString());</span><br><span class="line">    uuidStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8允许你在集合对象上调用<code>stream</code>方法来创建一个Stream。Stream支持数据处理操作，所以开发者可以用高层数据处理结构来表示计算过程。</p><h2 id="Collection-vs-Stream"><a href="#Collection-vs-Stream" class="headerlink" title="Collection vs Stream"></a>Collection vs Stream</h2><p>下面的表格解释了Collection和Stream之间的不同。</p><p><img src="https://whyjava.files.wordpress.com/2015/10/collection_vs_stream.png" alt="Collection vs Stream"></p><p>让我们来详细讨论一下外部迭代和内部迭代，以及延迟求值。</p><h3 id="外部迭代-vs-内部迭代"><a href="#外部迭代-vs-内部迭代" class="headerlink" title="外部迭代 vs 内部迭代"></a>外部迭代 vs 内部迭代</h3><p>上面所示的代码中，Java8中的Stream API和原来的Collection API的不同在于谁控制了迭代——是迭代器还是使用了迭代器的用户。Stream API的用户只是提供了他们想要使用的操作，然后迭代器将这些操作施加在内部集合中的每一个元素上。当迭代内部集合时，这个过程是由迭代器自己处理的，这被叫做<strong>内部迭代</strong>。而在Collection API中使用<code>for-each</code>结构是一个<strong>外部迭代</strong>的例子。</p><p>有些人可能会争论，在Collection API中我们不需要使用其中的迭代器，因为<code>for-each</code>结构将会处理它，但<code>for-each</code>只是使用了迭代器API的人工迭代的语法糖而已。<code>for-each</code>结构虽然很简单，却有一些缺点——1）他是内在连续的，2）它导致命令式代码，3）它很难并行化。</p><h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>Stream不会进行计算直到一个最终的命令来调用它。在Stream API中的大多数操作返回一个Stream。这些操作不会被执行——它们只是建立起管道流。让我们看一下下面的代码，并预测它的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = numbers.stream().map(n -&gt; n / <span class="number">0</span>).filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在上面所示的代码中，我们将一个数字流中的元素除以0。我们也许认为当代码执行时，它会抛出一个<code>ArithmeticException</code>的异常。但是，当你运行该代码时不会有异常抛出。这是因为Stream不会计算直到一个最终的命令调用它。如果在该管道流中添加最终的调用方法，那么该Stream将会执行，并抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = numbers.stream().map(n -&gt; n / <span class="number">0</span>).filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">stream.collect(toList());</span><br></pre></td></tr></table></figure><p>你将会得到类似下面的堆栈信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">at org._7dayswithx.java8.day2.EagerEvaluationExample.lambda$main$0(EagerEvaluationExample.java:13)</span><br><span class="line">at org._7dayswithx.java8.day2.EagerEvaluationExample$$Lambda$1&#x2F;1915318863.apply(Unknown Source)</span><br><span class="line">at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)</span><br><span class="line">at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)</span><br><span class="line">at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)</span><br><span class="line">at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)</span><br><span class="line">at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)</span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)</span><br></pre></td></tr></table></figure><h2 id="使用Stream-API"><a href="#使用Stream-API" class="headerlink" title="使用Stream API"></a>使用Stream API</h2><p>Stream API提供了很多开发者可以用来从集合中查询数据的操作。Stream操作分为两类——中间操作和结束操作。</p><p><strong>中间操作</strong>是从已有的Stream产生另一个Stream的函数，有<code>filter</code>、<code>map</code>、<code>sorted</code>等。</p><p><strong>结束操作</strong>是从Stream来产生一个不是Stream的结果的函数，有<code>collect(toList())</code>、<code>forEach</code>、<code>count</code>等。</p><p>中间操作允许你来构建管道流，它们会在你调用结束操作时被执行。下面是Stream API部分函数的列表。</p><p><a href="https://whyjava.files.wordpress.com/2015/07/stream-api.png" target="_blank" rel="noopener"><img class="aligncenter size-full wp-image-2983" src="https://whyjava.files.wordpress.com/2015/07/stream-api.png" alt="stream-api" height="450" /></a></p><h3 id="示例域"><a href="#示例域" class="headerlink" title="示例域"></a>示例域</h3><p>在这个教程中，我们将使用任务管理域来解释概念。我们的示例域有一个叫做<code>Task</code>的类——一个由用户来执行的任务。这个类如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDate createdOn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; tags = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LocalDate dueOn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removed constructor, getter, and setter for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子的数据集如下所示。我们将在Stream API示例中都使用这个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Task task1 = <span class="keyword">new</span> Task(<span class="string">"Read Version Control with Git book"</span>, TaskType.READING, LocalDate.of(<span class="number">2015</span>, Month.JULY, <span class="number">1</span>)).addTag(<span class="string">"git"</span>).addTag(<span class="string">"reading"</span>).addTag(<span class="string">"books"</span>);</span><br><span class="line"></span><br><span class="line">Task task2 = <span class="keyword">new</span> Task(<span class="string">"Read Java 8 Lambdas book"</span>, TaskType.READING, LocalDate.of(<span class="number">2015</span>, Month.JULY, <span class="number">2</span>)).addTag(<span class="string">"java8"</span>).addTag(<span class="string">"reading"</span>).addTag(<span class="string">"books"</span>);</span><br><span class="line"></span><br><span class="line">Task task3 = <span class="keyword">new</span> Task(<span class="string">"Write a mobile application to store my tasks"</span>, TaskType.CODING, LocalDate.of(<span class="number">2015</span>, Month.JULY, <span class="number">3</span>)).addTag(<span class="string">"coding"</span>).addTag(<span class="string">"mobile"</span>);</span><br><span class="line"></span><br><span class="line">Task task4 = <span class="keyword">new</span> Task(<span class="string">"Write a blog on Java 8 Streams"</span>, TaskType.WRITING, LocalDate.of(<span class="number">2015</span>, Month.JULY, <span class="number">4</span>)).addTag(<span class="string">"blogging"</span>).addTag(<span class="string">"writing"</span>).addTag(<span class="string">"streams"</span>);</span><br><span class="line"></span><br><span class="line">Task task5 = <span class="keyword">new</span> Task(<span class="string">"Read Domain Driven Design book"</span>, TaskType.READING, LocalDate.of(<span class="number">2015</span>, Month.JULY, <span class="number">5</span>)).addTag(<span class="string">"ddd"</span>).addTag(<span class="string">"books"</span>).addTag(<span class="string">"reading"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Task&gt; tasks = Arrays.asList(task1, task2, task3, task4, task5);</span><br></pre></td></tr></table></figure><blockquote><p>我们在这一节中不会讨论Java8的日期时间API。现在只要把它当做可读性高的日期相关的API即可。</p></blockquote><h3 id="例子1：找到所有的阅读任务并按照它们的创建日期排序"><a href="#例子1：找到所有的阅读任务并按照它们的创建日期排序" class="headerlink" title="例子1：找到所有的阅读任务并按照它们的创建日期排序"></a>例子1：找到所有的阅读任务并按照它们的创建日期排序</h3><p>我们讨论的第一个例子是找到所有的阅读任务，并按照它们的创建日期进行排序。我们需要执行的操作如下：</p><ol><li>过滤所有的任务来找到任务类型为<code>READING</code>的任务。</li><li>将过滤后的结果按照<code>createdOn</code>域进行排序。</li><li>获得每个任务的标题。</li><li>将结果的标题收集到一个列表中。</li></ol><p>上面的四个操作可以被容易地转换为如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">allReadingTasks</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTaskTitles = tasks.stream().</span><br><span class="line">                filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">                sorted((t1, t2) -&gt; t1.getCreatedOn().compareTo(t2.getCreatedOn())).</span><br><span class="line">                map(task -&gt; task.getTitle()).</span><br><span class="line">                collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> readingTaskTitles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面展示的代码中，我们使用了Stream API如下的方法：</p><ul><li><strong>filter</strong>：允许你指定一个断言来从数据流中排除一些元素。断言<strong>task-&gt;task.getType() ==TaskType.READING</strong>选择了所有任务类型为<code>READING</code>的任务。</li><li><strong>sorted</strong>：允许你指定一个比较器来对数据流进行排序。在这个例子中，你根据创建的日期来进行排序。lambda表达式<strong>(t1,t2)-&gt;t1.getCreatedOn().compareTo(t2.getCreatedOn())</strong> 提供了<code>Comparator</code>函数式接口的<code>compare</code>方法的实现。</li><li><strong>map</strong>：这需要一个实现了<code>Function&lt;? super T, ? extends R&gt;</code>接口的lambda表达式来将一个数据流转化为另一个数据流。lambda表达式<strong>task-&gt;task.getTitle()</strong>将一个任务转化为一个标题。</li><li><strong>collect(toList())</strong>：这是一个结束操作，它收集结果中的阅读任务的标题并放入列表。</li></ul><p>我们可以像下面一样通过使用<code>Comparator</code>接口的<code>comparing</code>方法和方法引用来优化上面的Java8代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allReadingTasks</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            sorted(Comparator.comparing(Task::getCreatedOn)).</span><br><span class="line">            map(Task::getTitle).</span><br><span class="line">            collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从Java8开始，接口可以以静态方法和默认方法的形式来拥有方法的实现。这些内容在<a href="./01-default-static-interface-methods.md">第一节</a>中。</p></blockquote><p>在上面展示的代码中，我们用了一个由<code>Comparator</code>接口提供的静态辅助方法<code>comparing</code>，它以<code>Function</code>接口为参数，而<code>Function</code>方法提取一个<code>Comparable</code>的键，并返回一个根据该键进行比较的比较器。方法引用<code>Task::getCreatedOn</code>相当于一个<code>Function&lt;Task, LocalDate&gt;</code>。</p><p>如下所示，通过使用复合函数，我们可以轻易地通过在比较器上调用<code>reversed</code>方法来编写将元素反向排序的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allReadingTasksSortedByCreatedOnDesc</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            sorted(Comparator.comparing(Task::getCreatedOn).reversed()).</span><br><span class="line">            map(Task::getTitle).</span><br><span class="line">            collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：找到唯一的任务"><a href="#例子2：找到唯一的任务" class="headerlink" title="例子2：找到唯一的任务"></a>例子2：找到唯一的任务</h3><p>假设我们的数据集中有重复的任务。如下所示，我们可以在数据流上使用<code>distinct</code>方法来轻易地去除重复元素从而得到唯一的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Task&gt; <span class="title">allDistinctTasks</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().distinct().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>distinct</code>方法将一个数据流转化成另一个没有重复元素的数据流。它使用对象的<code>equals</code>方法来决定对象是否相等。根据对象<code>equals</code>方法的约定，当两个对象相等的时候，它们被认为是重复的，然后其中一个会从结果数据流中被移除。</p><h3 id="例子3：找到根据创建日期排序的前5名的阅读任务"><a href="#例子3：找到根据创建日期排序的前5名的阅读任务" class="headerlink" title="例子3：找到根据创建日期排序的前5名的阅读任务"></a>例子3：找到根据创建日期排序的前5名的阅读任务</h3><p><code>limit</code>方法可以用来将结果集限定为特定的大小。<code>limit</code>方法是一个逻辑短路操作，也就是说它不会遍历所有的元素来得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topN</span><span class="params">(List&lt;Task&gt; tasks, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            sorted(comparing(Task::getCreatedOn)).</span><br><span class="line">            map(Task::getTitle).</span><br><span class="line">            limit(n).</span><br><span class="line">            collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，你可以将<code>limit</code>方法和<code>skip</code>方法一起使用来创建分页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page starts from 0. So to view a second page `page` will be 1 and n will be 5.</span></span><br><span class="line">List&lt;String&gt; readingTaskTitles = tasks.stream().</span><br><span class="line">                filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">                sorted(comparing(Task::getCreatedOn).reversed()).</span><br><span class="line">                map(Task::getTitle).</span><br><span class="line">                skip(page * n).</span><br><span class="line">                limit(n).</span><br><span class="line">                collect(toList());</span><br></pre></td></tr></table></figure><h3 id="例子4：计算所有阅读任务的数量"><a href="#例子4：计算所有阅读任务的数量" class="headerlink" title="例子4：计算所有阅读任务的数量"></a>例子4：计算所有阅读任务的数量</h3><p>为了得到所有阅读任务的数量，我们可以在数据流上使用<code>count</code>方法。这个方法是一个结束操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countAllReadingTasks</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子5：从所有的任务中找出所有不同的标签"><a href="#例子5：从所有的任务中找出所有不同的标签" class="headerlink" title="例子5：从所有的任务中找出所有不同的标签"></a>例子5：从所有的任务中找出所有不同的标签</h3><p>为了找出所有不同的标签，我们需要进行如下的操作：</p><ol><li>为每一个任务提取标签。</li><li>将所有的标签收集进一个数据流。</li><li>将重复的标签除去。</li><li>最后将收集的结果放入一个列表。</li></ol><p>第一个和第二个操作可以通过在<code>tasks</code>数据流上使用<code>flatMap</code>操作来完成。<code>flatMap</code>操作将每次调用<code>tasks.getTags().stream()</code>产生的数据流合并到一个中。一旦我们将所有标签放入一个数据流中，我们可以仅仅通过<code>distinct</code>方法来获取所有不同的标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">allDistinctTags</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().flatMap(task -&gt; task.getTags().stream()).distinct().collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子6：检查是否所有的阅读任务都有books标签"><a href="#例子6：检查是否所有的阅读任务都有books标签" class="headerlink" title="例子6：检查是否所有的阅读任务都有books标签"></a>例子6：检查是否所有的阅读任务都有<code>books</code>标签</h3><p>Stream API提供了方法让用户来检查数据集中元素的某一属性是否符合要求。这些方法是<code>allMatch</code>、<code>anyMatch</code>、<code>findFirst</code>和<code>findAny</code>。为了检查是否所有的阅读任务都一个名叫<code>books</code>的标签，我们可以编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllReadingTasksWithTagBooks</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            allMatch(task -&gt; task.getTags().contains(<span class="string">"books"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了检查是否有阅读任务有<code>java8</code>标签，我们可以像下面这样使用<code>anyMatch</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnyReadingTasksWithTagJava8</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            filter(task -&gt; task.getType() == TaskType.READING).</span><br><span class="line">            anyMatch(task -&gt; task.getTags().contains(<span class="string">"java8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子7：创建一个所有标题的总结"><a href="#例子7：创建一个所有标题的总结" class="headerlink" title="例子7：创建一个所有标题的总结"></a>例子7：创建一个所有标题的总结</h3><p>假设你想创建一个所有标题的总结。使用<code>reduce</code>操作，它将数据流缩减为一个值。<code>reduce</code>方法以将数据流中元素进行连接的lambda表达式为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">joinAllTaskTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().</span><br><span class="line">            map(Task::getTitle).</span><br><span class="line">            reduce((first, second) -&gt; first + <span class="string">" *** "</span> + second).</span><br><span class="line">            get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子8：与原始流一同工作"><a href="#例子8：与原始流一同工作" class="headerlink" title="例子8：与原始流一同工作"></a>例子8：与原始流一同工作</h3><p>除了作用在对象上的通用的数据流，Java8还提供了特殊的数据流来处理原始类型，像int、long和double。让我看一些原始数据流的例子。</p><p>为了创建一个范围的值，我们可以使用<code>range</code>方法，它能创建一个从0开始到9的数据流，它不包括10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>rangeClosed</code>方法允许你创建包含右边界的数据流。所以下面的数据流将从1开始，到10结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>你也可以像下面这样通过<code>iterate</code>方法在原始数据流上创建一个无限的数据流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongStream infiniteStream = LongStream.iterate(<span class="number">1</span>, el -&gt; el + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>为过滤掉无限数据流中所有的偶数，我们可以编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infiniteStream.filter(el -&gt; el % <span class="number">2</span> == <span class="number">0</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>我们可以像下面这样通过使用<code>limit</code>操作来限制结果数据流的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infiniteStream.filter(el -&gt; el % <span class="number">2</span> == <span class="number">0</span>).limit(<span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="例子9：从Arrays来创建数据流"><a href="#例子9：从Arrays来创建数据流" class="headerlink" title="例子9：从Arrays来创建数据流"></a>例子9：从Arrays来创建数据流</h3><p>如下所示，你可以通过使用<code>Arrays</code>类的静态方法<code>stream</code>来从数组创建数据流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] tags = &#123;<span class="string">"java"</span>, <span class="string">"git"</span>, <span class="string">"lambdas"</span>, <span class="string">"machine-learning"</span>&#125;;</span><br><span class="line">Arrays.stream(tags).map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>你也可像下面这样从一个数组特定的起始下标到结束下标来创建一个数据流。在这里，起始下标被包含在内，而结束下标没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(tags, <span class="number">1</span>, <span class="number">3</span>).map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并行数据流"><a href="#并行数据流" class="headerlink" title="并行数据流"></a>并行数据流</h2><p>你使用<code>Stream</code>抽象的一大优势就是这个库能够有效地管理并行，就像迭代器也在容器内部一样。你可以通过调用数据流的<code>parallel</code>方法来使一个数据流并行。<code>parallel</code>方法底层使用了jdk7的<code>fork-join</code> API。默认地，它会将线程数上升到与主机CPU数量相等的数目。在下面所示的代码中，我们将数字按照处理它们的线程来进行分组。你将会在第四章中学习到<code>collect</code>和<code>groupingBy</code>方法。现在只需要理解它们允许你根据一个键来将元素分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelStreamExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; numbersPerThread = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">160</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .boxed()</span><br><span class="line">                .collect(groupingBy(i -&gt; Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line">        numbersPerThread.forEach((k, v) -&gt; System.out.println(String.format(<span class="string">"%s &gt;&gt; %s"</span>, k, v)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序在我电脑上的输出如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-7 &gt;&gt; [46, 47, 48, 49, 50]</span><br><span class="line">ForkJoinPool.commonPool-worker-1 &gt;&gt; [41, 42, 43, 44, 45, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130]</span><br><span class="line">ForkJoinPool.commonPool-worker-2 &gt;&gt; [146, 147, 148, 149, 150]</span><br><span class="line">main &gt;&gt; [106, 107, 108, 109, 110]</span><br><span class="line">ForkJoinPool.commonPool-worker-5 &gt;&gt; [71, 72, 73, 74, 75]</span><br><span class="line">ForkJoinPool.commonPool-worker-6 &gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160]</span><br><span class="line">ForkJoinPool.commonPool-worker-3 &gt;&gt; [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 76, 77, 78, 79, 80]</span><br><span class="line">ForkJoinPool.commonPool-worker-4 &gt;&gt; [91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145]</span><br></pre></td></tr></table></figure><p>不是每一个线程处理一样多的元素。你可以通过设置系统属性<code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;,&quot;2&quot;)</code>来控制<code>fork-join</code>线程池的大小。</p><p>如下所示，另一个你可以使用到<code>parallel</code>操作的地方是你操作一个URL的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] urls = &#123;<span class="string">"https://www.google.co.in/"</span>, <span class="string">"https://twitter.com/"</span>, <span class="string">"http://www.facebook.com/"</span>&#125;;</span><br><span class="line">Arrays.stream(urls).parallel().map(url -&gt; getUrlContent(url)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>如果你要理解何时来使用并行数据流，我建议你阅读Doug Lea et al的这篇文章 <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;./2020/04/15/java8-lambda/&quot;&gt;第二章&lt;/a&gt;中，我们通过学习lambda表达式，了解了如何能够在不创建额外类的情况下传递行为来帮助我们编写出简洁精练的代码。lambda表达式是一种通过使用函数式接口让开发者能够快速表达他们的想法的语言概念。设计API的时候将lambda，也就是那些使用了函数式接口的流畅的API（我们在&lt;a href=&quot;./02-lambdas.md#lambda表达式是如何在Java8中工作的&quot;&gt;lambdas章节&lt;/a&gt;中讨论过它们）记在脑子中，我们才能真正体验到lambda的强大。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/categories/java/"/>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8-lambda</title>
    <link href="http://ysocks.gitee.io/2020/04/15/java8-lambda/"/>
    <id>http://ysocks.gitee.io/2020/04/15/java8-lambda/</id>
    <published>2020-04-15T02:41:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。</p><a id="more"></a><p>Java8在使世界上最受欢迎的编程语言之一在接纳函数式编程的过程中向前迈了一大步。为了支持函数式编程，编程语言必须将函数作为<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6" target="_blank" rel="noopener">第一类对象</a>。在Java8之前，如果没有使用一个匿名内部类模板是没法写出清晰的函数式代码的。随着lambda表达式的引入，函数已经成为第一类对象，并能够像其它变量一样被到处传递。</p><p>lambda表达式允许你定义一个不与标识符绑定的匿名函数。你可以像编程语言中的其它概念一样使用它们，比如变量的声明。当一个编程语言需要支持高阶函数时，就需要用到lambda表达式。高阶函数是指以其它函数作为参数或者返回函数作为结果的函数。</p><blockquote><p>这一节的代码在<a href="https://github.com/shekhargulati/java8-the-missing-tutorial/tree/master/code/src/main/java/com/shekhargulati/java8_tutorial/ch02" target="_blank" rel="noopener">ch02</a>包中</p></blockquote><p>现在，随着在Java8中引进了lambda表达式，Java已经支持高阶函数。让我来看一个lambda表达式的典型例子——<code>Collections</code>类中的<code>sort</code>方法。<code>sort</code>方法有两种变体——一种以一个<code>List</code>作为参数，另一个以<code>List</code>和<code>Comparator</code>作为参数。如下面的代码块所示，第二种<code>sort</code>方法是一个接受lambda表达式的高阶函数的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"shekhar"</span>, <span class="string">"rahul"</span>, <span class="string">"sameer"</span>);</span><br><span class="line">Collections.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><p>上面的代码将姓名链表按照元素的长度进行排序。该程序的输出如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rahul, sameer, shekhar]</span><br></pre></td></tr></table></figure><p>上面代码块中的表达式<code>(first, second) -&gt; first.length() - second.length()</code>是一个<code>Comparator&lt;String&gt;</code>类型的lambda表达式。</p><ul><li><code>(first, second)</code>是比较器<code>Comparator</code>的<code>compare</code>方法。</li><li><code>first.length() - second.length()</code> 是用来比较两个名字长度的方法实体。</li><li><code>-&gt;</code>是lambda操作符，用来将参数和方法体分离开。</li></ul><p>在我们继续深挖Java8的lambda表达式之前，让我们来看看lambda的历史来理解为什么会存在lambda。</p><h2 id="lambda的历史"><a href="#lambda的历史" class="headerlink" title="lambda的历史"></a>lambda的历史</h2><p>lambda表达式源自λ演算。<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a>由<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87" target="_blank" rel="noopener">Alonzo Church</a>在将带有函数的符号计算进行公式化时提出。λ演算是具有图灵完备性的，它通过数学形式来展现计算过程。图灵完备性表示你可以通过lambda表达任何的数学计算。</p><p>λ演算成为了函数式编程语言的一个坚实的理论基础。很多有名的函数式编程语言，像Haskell和Lisp都是构建在λ演算的基础上的。高阶函数的概念，比如接受其他函数为输入的函数也来自λ演算。</p><p>λ演算的核心概念是表达式。一个lambda表达式可以表示为如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; :&#x3D; &lt;variable&gt; | &lt;function&gt;| &lt;application&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>variable</strong>–变量就是类似x,y,z的占位符，它们用来表示具体的像1,2之类的值，或者lambda方法。</li><li><strong>functrion</strong>–这是一个匿名的方法定义，它需要一个变量，并产生另一个lambda表达式。例如，<code>λx.x*x</code>是一个用来计算数的平方的方法。</li><li><strong>application</strong>–这是将具体的参数应用在函数上的行为。假设你想得到10的平方，那么在λ演算中你会写一个平方函数<code>λx.x*x</code>，并把10代入。这个函数应用将得到<code>(λx.x*x) 10 = 10*10 = 100</code>。你不仅仅能够代入简单的像10一样的值，你可以将一个函数代入另一个函数来得到一个新的函数。例如，<code>(λx.x*x) (λz.z+10)</code>将会生成一个函数<code>λz.(z+10)*(z+10)</code>。现在，你可以用这个函数得到一个数加上10以后的平方。这是一个高阶函数的例子。</li></ul><p>现在你理解了λ演算和它在函数式编程语言中的影响。让我们来学习它是如何在Java8中实现的。</p><h2 id="在Java8之前传递行为的方式"><a href="#在Java8之前传递行为的方式" class="headerlink" title="在Java8之前传递行为的方式"></a>在Java8之前传递行为的方式</h2><p>在Java8之前，唯一能够用来传递行为的方式是通过匿名类。假设你想要在用户完成注册的同时在另一个线程中给该用户发送一封邮件。在Java8之前，你会写出类似下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sendEmail(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Sending email..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>sendEmail</code>方法拥有如下的方法签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(Runnable runnable)</span></span></span><br></pre></td></tr></table></figure><p>上面提到的代码的问题不仅仅是我们需要封装我们的行为，如将<code>run</code>方法直接放在一个对象中，更严重的问题是它丢失了程序员的意图，如将行为传递到<code>sendEmail</code>方法中。如果你使用过Guava类库，你肯定感受到了编写匿名类的痛苦。一个简单的用来过滤所有任务的标题中有<strong>lambda</strong>的例子如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;Task&gt; lambdaTasks = Iterables.filter(tasks, <span class="keyword">new</span> Predicate&lt;Task&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input.getTitle().contains(<span class="string">"lambda"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有了Java8的Stream API，你可以在不使用像Guava一样的第三方库的情况下写出上面提及的代码。我们将在<a href="">第三章</a>中讲解Stream，敬请期待。</p><h2 id="Java8-lambda表达式"><a href="#Java8-lambda表达式" class="headerlink" title="Java8 lambda表达式"></a>Java8 lambda表达式</h2><p>在Java8中，我们将使用lambda表达式写出如下的代码。这与我们上面提及过的代码段相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendEmail(() -&gt; System.out.println(<span class="string">"Sending email..."</span>));</span><br></pre></td></tr></table></figure><p>上面的展示的代码非常简练，也没有污染程序员想要传递的行为。<code>()</code>用来表示这个lambda表达式没有参数，像<code>Runnable</code>接口中的<code>run</code>方法就没有任何参数。<code>-&gt;</code>是将参数和用来打印出<code>Sending email</code>的方法主体分隔开的lambda操作符。</p><p>让我再来看看<code>Collections.sort</code>这个例子来了解lambda表达式是如何使用参数的。为了使名字能够按照它们的长度进行排列，我们向排序方法传入了一个<code>Comparator</code>。该<code>Comparator</code>如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure><p>我们编写的lambda表达式与<code>Comparator</code>接口中的<code>compare</code>方法相关联。<code>compare</code>方法的签名如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br></pre></td></tr></table></figure><p><code>T</code>是传给<code>Comparator</code>接口的类型参数。由于我们是对一组表示名字的字符串进行操作，所以这个例子中它将是字符串类型的。在lambda表达式中我们不需要特意提供该类型——字符串。<code>javac</code>编译器会从上下文中推断出它的类型信息。由于我们在给一组字符串排序，Java编译器会推测出两个参数都应该是字符串，而<code>compare</code>方法只标明需要<code>T</code>这一种类型。像这样通过上下文推断类型的行为称作类型推断。Java8优化了Java原有的类型推断机制，使得它更具有鲁棒性，并能够更好地支持lambda表达式。<code>javac</code>会在后台寻找与你lambda表达式相关的信息，并使用该信息来找到参数正确的类型。</p><blockquote><p>在大多数情况下，<code>javac</code>会从上下文中推断出类型。如果由于上下文缺失或不完整导致代码不能进行编译，它也就不能推断出类型。例如如果我们将<code>String</code>的类型信息从<code>Comparator</code>中移除，那么代码会像下面一样编译失败。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator comparator = (first, second) -&gt; first.length() - second.length(); <span class="comment">// compilation error - Cannot resolve method 'length()'</span></span><br></pre></td></tr></table></figure><h2 id="lambda表达式是如何在Java8中工作的？"><a href="#lambda表达式是如何在Java8中工作的？" class="headerlink" title="lambda表达式是如何在Java8中工作的？"></a>lambda表达式是如何在Java8中工作的？</h2><p>你也许已经发现lambda表达式是与上面例子中的<code>Comparator</code>类似的一些接口。你不能对任意的接口使用lambda表达式。<strong><em>只有那些除了Object的方法外只定义了唯一抽象方法的接口可以使用lambda表达式。</em></strong>这一类的接口被称作<strong>函数式接口</strong>，它们可以通过<code>@FunctionalInterface</code>注解来进行注解。如下所示，<code>Runnable</code>接口就是一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@FunctionalInterface</code>注解不是强制需要的，它能够帮助其他工具知道这个接口是一个函数式接口，以此展现出有意义的行为。如果你试图编译一个有<code>@FunctionalInterface</code>的接口，而该接口有多个抽象方法，那么编译器将会抛出一个<strong><em>发现多个没有重写的抽象方法</em></strong>的异常。同样的，如果你对一个没有任何方法的接口添加<code>@FunctionalInterface</code>的注解，比如一个标记接口，那么你将会得到一条<strong><em>没有找到目标方法的</em></strong>的消息。</p><p>让我们来解答一个你也许会想到的最重要的问题。<strong><em>Java8中的lambda表达式是仅仅针对匿名类的语法糖吗，或者说函数式接口是如何转换为字节码的？</em></strong>简单的答案是<strong>不是</strong>。Java8不使用匿名内部类主要有两个原因：</p><ol><li><p><strong>性能开销</strong>：如果lambda表达式是通过使用匿名类来实现的，那么每一个lambda表达式都要在磁盘上产生一个文件。如果这些类在JVM启动时被加载，那么JVM的启动时间将会增加，因为所有的类在使用前都要进行加载和验证。</p></li><li><p><strong>未来改变的可能性</strong>：如果Java8的设计者从开始就使用了匿名类，那么这将限制lambda表达式的实现方式在将来的变化。</p></li></ol><h3 id="使用invokedynamic"><a href="#使用invokedynamic" class="headerlink" title="使用invokedynamic"></a>使用invokedynamic</h3><p>Java8设计者决定使用在Java7中添加的<code>invokedynamic</code>指令来在运行时推迟编译策略的执行。当<code>javac</code>编译代码的时候，它会捕捉到lambda表达式并生成一个<code>invokedynamic</code>的调用（被叫做lambda工厂）。当<code>invokedynamic</code>命令被调用时，它会返回一个lambda要转化的函数式接口的实例。例如，我来查看<code>Collections.sort</code>的字节码，它如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_3</span><br><span class="line">       1: anewarray     #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String</span><br><span class="line">       4: dup</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: ldc           #3                  &#x2F;&#x2F; String shekhar</span><br><span class="line">       8: aastore</span><br><span class="line">       9: dup</span><br><span class="line">      10: iconst_1</span><br><span class="line">      11: ldc           #4                  &#x2F;&#x2F; String rahul</span><br><span class="line">      13: aastore</span><br><span class="line">      14: dup</span><br><span class="line">      15: iconst_2</span><br><span class="line">      16: ldc           #5                  &#x2F;&#x2F; String sameer</span><br><span class="line">      18: aastore</span><br><span class="line">      19: invokestatic  #6                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;Arrays.asList:([Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;util&#x2F;List;</span><br><span class="line">      22: astore_1</span><br><span class="line">      23: invokedynamic #7,  0              &#x2F;&#x2F; InvokeDynamic #0:compare:()Ljava&#x2F;util&#x2F;Comparator;</span><br><span class="line">      28: astore_2</span><br><span class="line">      29: aload_1</span><br><span class="line">      30: aload_2</span><br><span class="line">      31: invokestatic  #8                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;Collections.sort:(Ljava&#x2F;util&#x2F;List;Ljava&#x2F;util&#x2F;Comparator;)V</span><br><span class="line">      34: getstatic     #9                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      37: aload_1</span><br><span class="line">      38: invokevirtual #10                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      41: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码有意思的地方在第23行<code>23: invokedynamic #7,  0              // InvokeDynamic #0:compare:()Ljava/util/Comparator;</code>，也就是生成一个<code>invokedynamic</code>的地方。</p><p>第二步是将lambda表达式的主体部分转化成通过<code>invokedynamic</code>指令调用的方法。这一步让JVM实现者能够自由地选取他们自己的策略。我省略了这个话题相关的内容，你可以在<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html中阅读到更多的内容。" target="_blank" rel="noopener">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html中阅读到更多的内容。</a></p><h2 id="匿名类-vs-lambda"><a href="#匿名类-vs-lambda" class="headerlink" title="匿名类 vs lambda"></a>匿名类 vs lambda</h2><p>让我们通过比较匿名类和lambda表达式来比较它们的不同。</p><ol><li>在匿名类中，<code>this</code>表示匿名类自己，而在lambda表达式中，<code>this</code>表示包含了lambda表达式的类。</li><li>你可以在匿名类这个封闭类中隐藏变量。在lambda表达式中这么做时将产生一个编译错误。</li><li>lambda表达式的类型是由上下文决定的，而匿名类的类型是由你创建匿名类时指定的。</li></ol><h2 id="我需要自己编写函数式接口吗？"><a href="#我需要自己编写函数式接口吗？" class="headerlink" title="我需要自己编写函数式接口吗？"></a>我需要自己编写函数式接口吗？</h2><p>Java8默认提供了好多函数式编程接口来供你在代码中使用。它们在<code>java.util.function</code>包中。让我们看一下其中的一部分。</p><h3 id="java-util-function-Predicate"><a href="#java-util-function-Predicate" class="headerlink" title="java.util.function.Predicate"></a>java.util.function.Predicate<T></h3><p>这个函数式接口被用来定义某些情形的检查，类似于断言。<code>Predicate</code>接口有一个叫做<code>test</code>的方法，它以泛型<code>T</code>为参数，返回一个布尔值。举例来说，如果我们想从一串名字中找到所有以<strong>s</strong>开头的名字，那么我们将向下面这样使用<code>Predicate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; namesStartingWithS = name -&gt; name.startsWith(<span class="string">"s"</span>);</span><br></pre></td></tr></table></figure><h3 id="java-util-function-Consumer"><a href="#java-util-function-Consumer" class="headerlink" title="java.util.function.Consumer"></a>java.util.function.Consumer<T></h3><p>这个函数式接口被用来执行一些不用产生输出的动作。<code>Comsumer</code>接口有一个以泛型<code>T</code>为参数且没有返回值的<code>accept</code>方法。比如将一条给定的信息通过邮件发出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; messageConsumer = message -&gt; System.out.println(message);</span><br></pre></td></tr></table></figure><h3 id="java-util-function-Function-lt-T-R-gt"><a href="#java-util-function-Function-lt-T-R-gt" class="headerlink" title="java.util.function.Function&lt;T,R&gt;"></a>java.util.function.Function&lt;T,R&gt;</h3><p>这个函数式接口接受一个参数并产生一个结果。例如，如果我们想要将姓名列表中的所有名字都大写，我们可以写一个像下面这样的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, String&gt; toUpperCase = name -&gt; name.toUpperCase();</span><br></pre></td></tr></table></figure><h3 id="java-util-function-Supplier"><a href="#java-util-function-Supplier" class="headerlink" title="java.util.function.Supplier"></a>java.util.function.Supplier<T></h3><p>这个函数式接口不需要任何参数，却会产生一个值。这可以被用来像下面这样生成唯一标志码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; uuidGenerator= () -&gt; UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><p>我们将在这一系列教程中涉及更多的函数式接口。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时候你会创建一些只调用特定方法的lambda表达式，比如<code>Function&lt;String, Integer&gt; strToLength = str -&gt;str.length();</code>。这个lambda只在<code>String</code>对象上调用<code>length()</code>方法。这种情况可以通过使用方法引用来简化成<code>Function&lt;String, Integer&gt;strToLength = String::length;</code>。这可以被看做是只调用单个方法的lambda表达式的简化标记。在该表达式<code>String::length</code>中，<code>String</code>是目标引用，<code>::</code>是分隔符，<code>length</code>是在目标引用中将会被调用的方法。你在静态方法和实例方法中都可以使用方法引用。</p><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>假设我们要找到一串数中最大的一个，那么我们可以写一个像<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn =Collections::max</code>这样的方法引用。<code>max</code>是<code>Collections</code>类中一个以<code>list</code>为参数的静态方法。然后你可以像<code>maxFn.apply(Arrays.asList(1, 10, 3, 5))</code>这样来调用。上面的lambda表达式是与<code>Function&lt;List&lt;Integer&gt;, Integer&gt; maxFn = (numbers) -&gt;Collections.max(numbers);</code>等价的。</p><h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>这是一类为实例方法使用的方法引用，比如在<code>String::toUpperCase</code>在<code>String</code>引用上调用了<code>toUpperCase</code>方法。你也可以对有参数的方法使用方法引用，像<code>BiFunction&lt;String,String, String&gt; concatFn = String::concat</code>。<code>concatFn</code>可以像<code>concatFn.apply(&quot;shekhar&quot;, &quot;gulati&quot;)</code>这样被调用。<code>concat</code>方法是字符串对象的需要一个参数的方法，形式为<code>&quot;shekhar&quot;.concat(&quot;gulati&quot;)</code>。</p><h2 id="练习-gt-gt-写自己的lambda"><a href="#练习-gt-gt-写自己的lambda" class="headerlink" title="练习&gt;&gt;写自己的lambda"></a>练习&gt;&gt;写自己的lambda</h2><p>让我们看一下下面的代码，并把我们学的应用起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks);</span><br><span class="line">        <span class="keyword">for</span> (String title : titles) &#123;</span><br><span class="line">            System.out.println(title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.getType() == TaskType.READING) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码首先从一个工具方法<code>getTasks</code>中获取所有的任务。我们对<code>getTasks</code>方法的内部实现不感兴趣。<code>getTasks</code>方法可以从web、数据库或者内存中来获取任务。一旦你有了任务，我们过滤出所有的阅读任务并抽取出这些任务的标题。我们将抽取的标题存入一个链表并最终返回所有的阅读标题。</p><p>让我们从最简单的重构开始——通过方法引用在链表上使用<code>foreach</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks);</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.getType() == TaskType.READING) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>Predicate&lt;T&gt;</code>来过滤我们的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING);</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(task.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>Function&lt;T,R&gt;</code>来从我们的任务中抽取标题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;String&gt; titles = taskTitles(tasks, task -&gt; task.getType() == TaskType.READING, task -&gt; task.getTitle());</span><br><span class="line">        titles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">taskTitles</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, Function&lt;Task, R&gt; extractor)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(extractor.apply(task));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对提取器使用方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">    List&lt;String&gt; titles = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getTitle);</span><br><span class="line">    titles.forEach(System.out::println);</span><br><span class="line">    List&lt;LocalDate&gt; createdOnDates = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Task::getCreatedOn);</span><br><span class="line">    createdOnDates.forEach(System.out::println);</span><br><span class="line">    List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, Function.identity());</span><br><span class="line">    filteredTasks.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以通过编写我们自己的<strong>函数式接口</strong>，这样可以清楚地描述开发者的意图。我们可以创建一个继承于<code>Function</code>接口的<code>TaskExtractor</code>接口。该接口的输入类型被限定为<code>Task</code>，输出类型由lambda的实现决定。这样由于输入类型始终是<code>Task</code>，开发者只需要关注返回值的类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exercise_Lambdas</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">        List&lt;Task&gt; filteredTasks = filterAndExtract(tasks, task -&gt; task.getType() == TaskType.READING, TaskExtractor.identityOp());</span><br><span class="line">        filteredTasks.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">filterAndExtract</span><span class="params">(List&lt;Task&gt; tasks, Predicate&lt;Task&gt; filterTasks, TaskExtractor&lt;R&gt; extractor)</span> </span>&#123;</span><br><span class="line">        List&lt;R&gt; readingTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterTasks.test(task)) &#123;</span><br><span class="line">                readingTitles.add(extractor.apply(task));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readingTitles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TaskExtractor</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">Task</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TaskExtractor&lt;Task&gt; <span class="title">identityOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8中最重要的特性之一就是引入了lambda表达式。这能够使你的代码更加简练，并允许你将行为传递到各处。一段时间以来，Java因为自身的冗长和缺少函数式编程的能力而受到批评。随着函数式编程变得越来越流行和有价值，Java也在努力接受函数式编程。否则，Java将会变得没有价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/categories/java/"/>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/tags/java/"/>
    
  </entry>
  
</feed>
