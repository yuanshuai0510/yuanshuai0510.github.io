<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YSocket&#39;s Blog</title>
  
  <subtitle>YSocket Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ysocks.gitee.io/"/>
  <updated>2020-11-19T08:24:35.144Z</updated>
  <id>http://ysocks.gitee.io/</id>
  
  <author>
    <name>YSocket</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8 对象集合按时间排序</title>
    <link href="http://ysocks.gitee.io/2020/11/19/sort-lit-by-object-time/"/>
    <id>http://ysocks.gitee.io/2020/11/19/sort-lit-by-object-time/</id>
    <published>2020-11-19T08:23:04.000Z</published>
    <updated>2020-11-19T08:24:35.144Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java8-对象集合按时间排序"><a href="#java8-对象集合按时间排序" class="headerlink" title="java8 对象集合按时间排序"></a>java8 对象集合按时间排序</h4><p>升序<br><code>coDoctorVOList.sort(Comparator.comparing(CoDoctorVO::getTime));</code></p><p>降序</p><p><code>coDoctorVOList.sort((m1, m2) -&gt; m2.getTime().compareTo(m1.getTime()));</code></p><p>ps:getTime()是对象中获取时间参数的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;java8-对象集合按时间排序&quot;&gt;&lt;a href=&quot;#java8-对象集合按时间排序&quot; class=&quot;headerlink&quot; title=&quot;java8 对象集合按时间排序&quot;&gt;&lt;/a&gt;java8 对象集合按时间排序&lt;/h4&gt;&lt;p&gt;升序&lt;br&gt;&lt;code&gt;coDoct
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nacos 1.4 code:503,msg:server is DOWN now, please try again later! </title>
    <link href="http://ysocks.gitee.io/2020/11/17/nacos-503-error/"/>
    <id>http://ysocks.gitee.io/2020/11/17/nacos-503-error/</id>
    <published>2020-11-17T10:58:17.000Z</published>
    <updated>2020-11-17T11:02:59.247Z</updated>
    
    <content type="html"><![CDATA[<p>现象：<br>今天电脑更换了ip,1.4.0版本 单机模式下 重启nacos出现如下错误:<br><code>错误：code:503,msg:server is DOWN now, please try again later!</code><br>原因:<br>1.4.0使用了jraft， jraft会记录前一次启动的集群地址，如果重启机器ip变了的话，会导致jraft记录的地址失效，从而导致选主出问题。</p><p>解决方式：<br>删除{nacos.home}/nacos/data/protocol文件夹后重新启动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现象：&lt;br&gt;今天电脑更换了ip,1.4.0版本 单机模式下 重启nacos出现如下错误:&lt;br&gt;&lt;code&gt;错误：code:503,msg:server is DOWN now, please try again later!&lt;/code&gt;&lt;br&gt;原因:&lt;br&gt;1.4.0
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java面试题目文档</title>
    <link href="http://ysocks.gitee.io/2020/10/30/java-document-list/"/>
    <id>http://ysocks.gitee.io/2020/10/30/java-document-list/</id>
    <published>2020-10-30T14:15:00.000Z</published>
    <updated>2020-10-31T15:04:49.035Z</updated>
    
    <content type="html"><![CDATA[<p>HowToDoInJava 中文系列教程<br><a href="http://ysocket.gitee.io/howtodoinjava-zh" target="_blank" rel="noopener">http://ysocket.gitee.io/howtodoinjava-zh</a></p><p>中华石杉–互联网Java进阶面试训练营<br><a href="http://ysocket.gitee.io/java-interview-advanced" target="_blank" rel="noopener">http://ysocket.gitee.io/java-interview-advanced</a></p><p>java工程师成神之路<br><a href="http://ysocket.gitee.io/toBeTopJavaer" target="_blank" rel="noopener">http://ysocket.gitee.io/toBeTopJavaer</a></p><p>Java 虚拟机底层原理知识总结<br><a href="http://ysocket.gitee.io/jvm" target="_blank" rel="noopener">http://ysocket.gitee.io/jvm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HowToDoInJava 中文系列教程&lt;br&gt;&lt;a href=&quot;http://ysocket.gitee.io/howtodoinjava-zh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ysocket.gitee.io/howtodo
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://ysocks.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下安装 dnsmasq 来配置开发环境</title>
    <link href="http://ysocks.gitee.io/2020/09/26/Mac-install-dnsmasq/"/>
    <id>http://ysocks.gitee.io/2020/09/26/Mac-install-dnsmasq/</id>
    <published>2020-09-26T03:06:00.000Z</published>
    <updated>2020-09-26T03:56:00.681Z</updated>
    
    <content type="html"><![CDATA[<p>由于实际的开发当中，可能存在多个项目的情况，如果是在本地自行搭建的坏境的话，就很有可能需要使用多个域名了，当然，也可以是 localhost / localhost:81 / localhost:82 这样来访问多个项目。其实，有更加便捷的方法（忽略自行修改/etc/hosts，这种哈，会改死人的），使用一个管理dns的工具： dnsmasq。  </p><ul><li>安装 dnsmasq  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install dnsmasq</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>编辑配置文件<br><code>vi /usr/local/etc/dnsmasq.conf</code> 修改内容: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolv-file&#x3D;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;resolv.dnsmasq.conf</span><br><span class="line">addn-hosts&#x3D;&#x2F;etc&#x2F;dnsmasq.hosts</span><br><span class="line">strict-order</span><br></pre></td></tr></table></figure></li><li><p>创建文件 <code>vi /usr/local/etc/resolv.dnsmasq.conf</code>  并添加内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen-address&#x3D;0.0.0.0</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 221.228.255.1</span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure></li><li><p>开发环境配置<br><code>vi /usr/local/etc/dnsmasq.conf</code><br>修改内容: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#dev-server</span><br><span class="line">address&#x3D;&#x2F;dev&#x2F;127.0.0.1 #这样的意思就是访问 ********.dev 直接引导到 127.0.0.0</span><br></pre></td></tr></table></figure></li><li><p>重启dnsmasq<br><code>sudo brew services restart dnsmasq</code></p></li></ul><p>最后wifi的dns只要配置一个127.0.0.1即可</p><ul><li>测试<br><code>ping abc.dev</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于实际的开发当中，可能存在多个项目的情况，如果是在本地自行搭建的坏境的话，就很有可能需要使用多个域名了，当然，也可以是 localhost / localhost:81 / localhost:82 这样来访问多个项目。其实，有更加便捷的方法（忽略自行修改/etc/hosts，这种哈，会改死人的），使用一个管理dns的工具： dnsmasq。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装 dnsmasq  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install dnsmasq&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="dns" scheme="http://ysocks.gitee.io/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>springboot多模块项目中配置国际化</title>
    <link href="http://ysocks.gitee.io/2020/08/22/springboot-multi-module-i18n/"/>
    <id>http://ysocks.gitee.io/2020/08/22/springboot-multi-module-i18n/</id>
    <published>2020-08-22T12:34:00.000Z</published>
    <updated>2020-08-22T12:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://www.cnblogs.com/weixinya/p/12893531.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixinya/p/12893531.html</a></p><p>在多个module组成的SpringBoot项目中，可以为每个module单独配置属于自己的国际化资源。</p><ol><li>模块单独添加国际化配置文件<br>每个module单独配置一套配置文件；需要注意的是：配置文件basename不能出现重复，否则会出现配置文件被其他模块的同名配置文件屏蔽的情况！这里建议使用各个module的模块名作为配置文件的basename，既避免出现重复，又逻辑清晰优雅。</li><li>配置查找国际化资源路径<br>在程序入口所在包下application.yml配置文件中，配置所引用的module中的国际化路径，通过“,”来配置多个module的国际化资源文件。如下所示：<br>application.yml中多module国际化配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  messages:</span><br><span class="line">    basename: i18n&#x2F;common,i18n&#x2F;publicRes,i18n&#x2F;roleRight,i18n&#x2F;userMsg</span><br><span class="line">    encoding: UTF-8</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://www.cnblogs.com/weixinya/p/12893531.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/weixinya/p/12893531.
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://ysocks.gitee.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://ysocks.gitee.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>mac查找指定文件类型下包含某个字符串的文件</title>
    <link href="http://ysocks.gitee.io/2020/08/21/find-file-include-same-string/"/>
    <id>http://ysocks.gitee.io/2020/08/21/find-file-include-same-string/</id>
    <published>2020-08-21T01:07:17.000Z</published>
    <updated>2020-08-22T12:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>想在整个文件夹下面查找包含字符串 “getAll”并且类型是.js的文件</p><p>终端命令：<br><code>find ./ -name &quot;*.js&quot; | xargs grep &quot;getAll&quot; -l</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想在整个文件夹下面查找包含字符串 “getAll”并且类型是.js的文件&lt;/p&gt;
&lt;p&gt;终端命令：&lt;br&gt;&lt;code&gt;find ./ -name &amp;quot;*.js&amp;quot; | xargs grep &amp;quot;getAll&amp;quot; -l&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>brew 安装zookeeper 3.4.14</title>
    <link href="http://ysocks.gitee.io/2020/07/29/brew_install_zookeeper_3_4_14/"/>
    <id>http://ysocks.gitee.io/2020/07/29/brew_install_zookeeper_3_4_14/</id>
    <published>2020-07-29T02:15:49.000Z</published>
    <updated>2020-07-29T02:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>brew 安装zookeeper 3.4.14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># force install zookeeper first</span><br><span class="line">brew install https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;6d8197bbb5f77e62d51041a3ae552ce2f8ff1344&#x2F;Formula&#x2F;zookeeper.rb</span><br><span class="line"></span><br><span class="line"># then force install kafka compatible with zookeeper 3.4.14</span><br><span class="line">brew install --ignore-dependencies https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;6d8197bbb5f77e62d51041a3ae552ce2f8ff1344&#x2F;Formula&#x2F;kafka.rb</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;brew 安装zookeeper 3.4.14&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MacOS brew 安装 consul</title>
    <link href="http://ysocks.gitee.io/2020/07/28/MacOS-brew-install-consul/"/>
    <id>http://ysocks.gitee.io/2020/07/28/MacOS-brew-install-consul/</id>
    <published>2020-07-28T15:34:00.000Z</published>
    <updated>2020-07-28T15:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装consul</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install consul</span><br></pre></td></tr></table></figure><p>配置consul：<br><code>vim /usr/local/opt/consul/homebrew.mxcl.consul.plist</code></p><p>修改 ProgramArguments 部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;consul&#x2F;bin&#x2F;consul&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;agent&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-server&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-bootstrap&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-advertise&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;127.0.0.1&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-data-dir&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;.&#x2F;data&lt;&#x2F;string&gt;</span><br><span class="line">      &lt;string&gt;-ui&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure><p>然后启动服务：<br><code>brew services start consul</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装consul&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code
      
    
    </summary>
    
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>MacOS zsh history命令显示操作时间</title>
    <link href="http://ysocks.gitee.io/2020/07/07/Mac-zsh-history-show-time/"/>
    <id>http://ysocks.gitee.io/2020/07/07/Mac-zsh-history-show-time/</id>
    <published>2020-07-07T05:41:00.000Z</published>
    <updated>2020-07-07T05:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -E</span></span><br><span class="line">    1   2.12.2013 14:19  cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -i</span></span><br><span class="line">    1  2013-12-02 14:19  history -E</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span> -D</span></span><br><span class="line">    1  0:00  history -E</span><br><span class="line">    2  0:00  history -I</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="mac" scheme="http://ysocks.gitee.io/categories/mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac GitBook安装和使用</title>
    <link href="http://ysocks.gitee.io/2020/06/20/Install-gitbook-on-mac/"/>
    <id>http://ysocks.gitee.io/2020/06/20/Install-gitbook-on-mac/</id>
    <published>2020-06-20T13:39:00.000Z</published>
    <updated>2020-06-20T13:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><p>安装npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"> &#x2F;&#x2F; 检查npm是否安装成功</span><br><span class="line"> npm -v</span><br><span class="line"> &#x2F;&#x2F; 检查node是否存在</span><br><span class="line"> node -v</span><br></pre></td></tr></table></figure></li><li><p>安装GitBook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gitbook是在npm环境下安装的，所以前提得先安装好npm。</span><br><span class="line">&#x2F;&#x2F; 安装Gitbook命令</span><br><span class="line">sudo npm install -g gitbook-cli</span><br><span class="line">&#x2F;&#x2F; 检查是否安装成功</span><br><span class="line">gitbook -v</span><br></pre></td></tr></table></figure></li><li><p>安装Gitbook Editor客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官网下载地址：https:&#x2F;&#x2F;www.gitbook.com&#x2F;editor</span><br><span class="line">用它辅助写文档很好用，可以登录从GitBook下载Book进行修改提交（我试过直接https进行拉取出错，后来直接云端下载同步到本地才能进行push操作）</span><br><span class="line">不过没有生成静态Html（_book那个文件夹），还需cd 命令进入book所在文件使用gitbook build这条命令进行生成。</span><br><span class="line">不过Gitbook网站里支持阅读和下载。</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>不能使用 npm install gitbook -g 命令安装，因为使用命令gitbook的时候会出现问题。</li><li>安装的命令前需要加入sudo,因为可能会找不到npm的 /usr/local/bin/路径。</li><li>使用gitbook -v命令检查时可能会不出现版本号，但其实是安装好了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装npm&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="gitbook" scheme="http://ysocks.gitee.io/categories/gitbook/"/>
    
    
      <category term="gitbook" scheme="http://ysocks.gitee.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>grep搜索子目录中包含某字符串的特定文件</title>
    <link href="http://ysocks.gitee.io/2020/06/04/grep-string-from-folder/"/>
    <id>http://ysocks.gitee.io/2020/06/04/grep-string-from-folder/</id>
    <published>2020-06-04T02:54:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>grep -n &quot;str&quot; -r ./</code></p><p>这是查找当前目录下以及下辖子目录下所有包含str字符串的文件,会列出文件名.以及该行的内容.以及行号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;grep -n &amp;quot;str&amp;quot; -r ./&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是查找当前目录下以及下辖子目录下所有包含str字符串的文件,会列出文件名.以及该行的内容.以及行号&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://ysocks.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql 分页</title>
    <link href="http://ysocks.gitee.io/2020/05/22/mysql-page/"/>
    <id>http://ysocks.gitee.io/2020/05/22/mysql-page/</id>
    <published>2020-05-22T14:25:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前借助mysql-plus分页，由于表数据越来越大 导致分页效率越来越低</p><p>改为用id来分页，效果明显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">A.* </span><br><span class="line">FROM</span><br><span class="line">time_machine_cmd A  </span><br><span class="line">JOIN </span><br><span class="line">    ( SELECT id FROM time_machine_cmd LIMIT 3000, 10 ) B</span><br><span class="line">    ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前借助mysql-plus分页，由于表数据越来越大 导致分页效率越来越低&lt;/p&gt;
&lt;p&gt;改为用id来分页，效果明显&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何重新安装 macOS 系统</title>
    <link href="http://ysocks.gitee.io/2020/05/16/how-to-reinstall-macos/"/>
    <id>http://ysocks.gitee.io/2020/05/16/how-to-reinstall-macos/</id>
    <published>2020-05-16T09:20:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家可能都知道了，重装 macOS 系统可以在重启 Mac 时按住 <strong>⌘-R</strong> 键。</p><a id="more"></a><p>R 应该就是「Recovery」的意思</p><p>当出现「实用工具」窗口时松开，然后选择「重新安装 macOS」。<br>这样会重新安装你现在 Mac 上的 macOS 版本。</p><p>这也是我们重新安装 macOS 系统最常用的方法。但除此之外还有别的方式。</p><p><strong>option-⌘-R</strong></p><p>重启 Mac 时按住 ⌘-R 键，当看到旋转地球出现时松开。</p><p>这样会升级到与你的 Mac 兼容的最新版 macOS。</p><p><strong>shift-option-⌘-R</strong></p><p>当看到旋转地球出现时松开。</p><p>这样会开始安装你电脑出场时的那个系统版本。</p><p>举个例子可能更好理解这三种的区别：</p><p>比如假设我的全新 MacBook Pro 购买时当初是 10.12.4，现在的版本是 10.13.1，然后现在的最新版本已经是 10.14.5。</p><p>如果我用 <strong>⌘-R</strong> 来重装，得到的就是升级之前一样的 10.13 的最新版，也就是10.13.4。</p><p>如果我用 <strong>option-⌘-R</strong> 来重装，得到的就是现在官方的最新版 10.14.5。</p><p>如果我用 <strong>shift-option-⌘-R</strong> 来重装，得到的就是我当初购买时候的 10.12.4。</p><p>以上方法重新安装系统都不会删除你原来的的文件和设置。</p><p>如果你想要在重装时先格式化你的磁盘，可以在 macOS 实用工具窗口选择「磁盘工具」，然后抹掉磁盘，再执行重新安装操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家可能都知道了，重装 macOS 系统可以在重启 Mac 时按住 &lt;strong&gt;⌘-R&lt;/strong&gt; 键。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac 10.14.6安装 brew</title>
    <link href="http://ysocks.gitee.io/2020/05/14/install-brew-on-mac/"/>
    <id>http://ysocks.gitee.io/2020/05/14/install-brew-on-mac/</id>
    <published>2020-05-14T06:27:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 10.14.6安装 brew</p><p>一、获取 install 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install &gt;&gt; brew_install</span><br></pre></td></tr></table></figure><a id="more"></a><p>二、更改脚本中的资源链接<br>替换<br><code>BREW_REPO = “https://github.com/Homebrew/brew“.freeze</code><br>为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BREW_REPO &#x3D; &quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git&quot;.freeze</span><br></pre></td></tr></table></figure><p>三、运行脚本</p><p><code>/usr/bin/ruby brew_install</code></p><p>四、下载homebrew-core</p><p>到下载homebrew-core这步会失败<br>失败后运行以下命令clone git库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core --depth&#x3D;1</span><br></pre></td></tr></table></figure><p>五、检查安装是否成功</p><p><code>brew doctor</code></p><p>六、添加清华大学镜像源</p><pre><code>echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&apos;&gt;&gt;   ~/.bash_profile</code></pre><p>使其生效<br><code>source ~/.bash_profile</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 10.14.6安装 brew&lt;/p&gt;
&lt;p&gt;一、获取 install 文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fsSL https:&amp;#x2F;&amp;#x2F;raw.githubusercontent.com&amp;#x2F;Homebrew&amp;#x2F;install&amp;#x2F;master&amp;#x2F;install &amp;gt;&amp;gt; brew_install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>常见 MySQL 的慢查询优化方式</title>
    <link href="http://ysocks.gitee.io/2020/05/13/%E5%B8%B8%E8%A7%81-MySQL-%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://ysocks.gitee.io/2020/05/13/%E5%B8%B8%E8%A7%81-MySQL-%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-13T02:38:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>慢查询日志概念</p><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。</p><a id="more"></a><p>默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>慢查询日志相关参数</p><p>MySQL 慢查询的相关参数解释：</p><ul><li>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><p>一，第一步.开启mysql慢查询<br>方式一：<br>修改配置文件  在 my.ini 增加几行:  主要是慢查询的定义时间，以及慢查询log日志记录（ slow_query_log）<br>方法二：通过MySQL数据库开启慢查询:</p><p>二，分析慢查询日志<br>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句<br>例如：执行</p><p><code>EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</code><br>得到如下结果：显示结果分析：<br><code>table |  type | possible_keys | key |key_len  | ref | rows | Extra</code><br>EXPLAIN列的解释:</p><ul><li>table   显示这一行的数据是关于哪张表的           </li><li>type    这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</li><li>rows   显示需要扫描行数</li><li>key     使用的索引</li></ul><p>三，常见的慢查询优化</p><p>（1）索引没起作用的情况</p><ul><li>使用LIKE关键字的查询语句<br>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</li><li>使用多列索引的查询语句<br>MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</li></ul><p>（2）优化数据库结构<br>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ul><li>将字段很多的表分解成多个表<br>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li><li>增加中间表<br>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</li></ul><p>（3）分解关联查询<br>将一个大的查询分解为多个小查询是很有必要的。<br>很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag </span><br><span class="line">JOIN tag_post ON tag_id &#x3D; tag.id</span><br><span class="line">JOIN post ON tag_post.post_id &#x3D; post.id</span><br><span class="line">WHERE tag.tag &#x3D; &#39;mysql&#39;;</span><br></pre></td></tr></table></figure><p>分解为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag WHERE tag &#x3D; &#39;mysql&#39;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id &#x3D; 1234;</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456,567);</span><br></pre></td></tr></table></figure><p>（4）优化LIMIT分页<br> 在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p> 一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p><p>优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p> 对于下面的查询：</p><p>  <code>select id,title from collect limit 90000,10;</code></p><p>该语句存在的最大问题在于limit M,N中偏移量M太大（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。</p><p> 如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次 查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</p><p>方法一：虑筛选字段（title）上加索引<br>title字段加索引  （此效率如何未加验证）</p><p>方法二：先查询出主键id值<br><code>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</code></p><p>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</p><p>方法三：“关延迟联”<br>如果这个表非常大，那么这个查询可以改写成如下的方式：<br>  <code>select news.id, news.description from news   inner join (select id from news order by title limit 50000,5) as myNew using(id);</code></p><p>这里的“关延迟联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><p>方法四：建立复合索引 acct_id和create_time<br><code>select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;慢查询日志概念&lt;/p&gt;
&lt;p&gt;MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://ysocks.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git merge –squash介绍</title>
    <link href="http://ysocks.gitee.io/2020/05/09/git-merge-squash/"/>
    <id>http://ysocks.gitee.io/2020/05/09/git-merge-squash/</id>
    <published>2020-05-09T13:07:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git相对于CVS和SVN的一大好处就是merge非常方便，只要指出branch的名字就好了，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge another</span><br><span class="line">$ git checkout another</span><br><span class="line"># modify, commit, modify, commit ...</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge another</span><br></pre></td></tr></table></figure><a id="more"></a><p>但是，操作方便并不意味着这样操作就是合理的，在某些情况下，我们应该优先选择使用<code>--squash</code>选项，如下：</p><pre><code>$ git merge --squash another$ git commit -m &quot;message here&quot;</code></pre><p><code>--squash</code>选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来。</p><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p><p>如果在开发分支上提交非常随意，甚至写成微博体，那么一定要使用<code>--squash</code>选项。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p><p>只有在开发分支上每个commit都有其独自存在的意义，并且能够编译通过的情况下（能够通过测试就更完美了），才应该选择缺省的合并方式来保留commit历史。</p><p>转自：<a href="https://www.cnblogs.com/lookphp/p/5799533.html" target="_blank" rel="noopener">git merge –squash介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git相对于CVS和SVN的一大好处就是merge非常方便，只要指出branch的名字就好了，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge another&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout another&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modify, commit, modify, commit ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge another&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac下设置 sublime Text3 在同一个窗口打开多个文件</title>
    <link href="http://ysocks.gitee.io/2020/05/07/open-multi-file-in-sublime/"/>
    <id>http://ysocks.gitee.io/2020/05/07/open-multi-file-in-sublime/</id>
    <published>2020-05-07T12:21:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开Sublime Text软件</p><p>点击左上角的<code>Sublime Text ---&gt; Preferences ---&gt; Settings－user</code></p><p>添加 <code>&quot;open_files_in_new_window&quot;:false</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开Sublime Text软件&lt;/p&gt;
&lt;p&gt;点击左上角的&lt;code&gt;Sublime Text ---&amp;gt; Preferences ---&amp;gt; Settings－user&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;&amp;quot;open_files_in_new
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://ysocks.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>git撤销commit 并保存之前的修改</title>
    <link href="http://ysocks.gitee.io/2020/05/07/git-revert-commit-keep-modify/"/>
    <id>http://ysocks.gitee.io/2020/05/07/git-revert-commit-keep-modify/</id>
    <published>2020-05-07T05:31:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>写完代码后，我们一般这样<br><code>git add .</code> //添加所有文件<br><code>git commit -m &quot;本功能全部完成&quot;</code></p><a id="more"></a><p>执行完commit后，想撤回commit，怎么办？</p><p>这样凉拌:</p><p><code>git reset --soft HEAD^</code></p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><p>说一下个人理解：</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><p>至于这几个参数：</p><p><code>--mixed</code></p><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p><p><code>--soft</code> </p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><p><code>--hard</code></p><p>删除工作空间改动代码，撤销commit，撤销git add .</p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><p>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：</p><p><code>git commit --amend</code></p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写完代码后，我们一般这样&lt;br&gt;&lt;code&gt;git add .&lt;/code&gt; //添加所有文件&lt;br&gt;&lt;code&gt;git commit -m &amp;quot;本功能全部完成&amp;quot;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git-stash 搁置修改</title>
    <link href="http://ysocks.gitee.io/2020/04/22/git-stash/"/>
    <id>http://ysocks.gitee.io/2020/04/22/git-stash/</id>
    <published>2020-04-22T11:18:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候写了一半的JAVA代码，都还不能编译通过的，就被叫去改另一个分支的bug了。  </p><a id="more"></a><p>在new分支上的时候在命令行输入：</p><p><code>git stash</code></p><p>或者</p><p><code>git stash save  “修改的信息&quot;</code></p><p>这样以后你的代码就回到自己上一个commit了，直接git stash的话git stash的栈会直接给你一个hash值作为版本的说明，如果用git stash save “修改的信息”，git stash的栈会把你填写的“修改的信息”作为版本的说明。</p><p>接下来你回到old分支修改代码完成，你又再回到new分支，输入：</p><p><code>git stash pop</code><br>或者<br><code>git stash list</code><br><code>git stash apply stash@{0}</code></p><p>就可以回到保存的版本了。</p><p><code>git stash pop</code>的作用是将<code>git stash</code>栈中最后一个版本取出来，<code>git stash apply stash@{0}</code>的作用是可以指定栈中的一个版本，通过<code>git stash list</code>可以看到所有的版本信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: On order-master-bugfix: 22222   </span><br><span class="line">stash@&#123;1&#125;: On order-master-bugfix: 22222</span><br></pre></td></tr></table></figure><p>然后你可以选择一个你需要的版本执行：</p><p><code>git stash apply stash@{0}</code></p><p>这时候你搁置的代码就回来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候写了一半的JAVA代码，都还不能编译通过的，就被叫去改另一个分支的bug了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/categories/git/"/>
    
    
      <category term="git" scheme="http://ysocks.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Collectors</title>
    <link href="http://ysocks.gitee.io/2020/04/16/Collectors/"/>
    <id>http://ysocks.gitee.io/2020/04/16/Collectors/</id>
    <published>2020-04-16T08:43:00.000Z</published>
    <updated>2020-06-04T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="./2020/04/15/Stream-API/">第二天</a>，你已经学习了Stream API能够让你以声明式的方式帮助你处理集合。我们看到<code>collect</code>是一个将管道流的结果集到一个<code>list</code>中的结束操作。<code>collect</code>是一个将数据流缩减为一个值的归约操作。这个值可以是集合、映射，或者一个值对象。你可以使用<code>collect</code>达到以下目的：</p><a id="more"></a><ol><li><p><strong>将数据流缩减为一个单一值：</strong>一个流执行后的结果能够被缩减为一个单一的值。单一的值可以是一个<code>Collection</code>，或者像int、double等的数值，再或者是一个用户自定义的值对象。</p></li><li><p><strong>将一个数据流中的元素进行分组：</strong>根据任务类型将流中所有的任务进行分组。这将产生一个<code>Map&lt;TaskType, List&lt;Task&gt;&gt;</code>的结果，其中每个实体包含一个任务类型以及与它相关的任务。你也可以使用除了列表以外的任何其他的集合。如果你不需要与一任务类型相关的所有的任务，你可以选择产生一个<code>Map&lt;TaskType, Task&gt;</code>。这是一个能够根据任务类型对任务进行分类并获取每类任务中第一个任务的例子。</p></li><li><p><strong>分割一个流中的元素：</strong>你可以将一个流分割为两组——比如将任务分割为要做和已经做完的任务。</p></li></ol><h2 id="Collector实际应用"><a href="#Collector实际应用" class="headerlink" title="Collector实际应用"></a>Collector实际应用</h2><p>为了感受到<code>Collector</code>的威力，让我们来看一下我们要根据任务类型来对任务进行分类的例子。在Java8中，我们可以通过编写如下的代码达到将任务根据类型分组的目的。<strong>请参考<a href="./03-streams.md">第二天</a>的博文，也就是我们讨论的在这一系列文章中我们将使用的任务域。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; groupTasksByType(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(Collectors.groupingBy(task -&gt; task.getType()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用了定义在辅助类<code>Collectors</code>中的<code>groupingBy</code>收集器。它创建了一个映射，其中<code>TaskType</code>是它的键，而包含了所有拥有相同<code>TaskType</code>的任务的列表是它的值。为了在Java7中达到相同的效果，你需要编写如下的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line">    Map&lt;TaskType, List&lt;Task&gt;&gt; allTasksByType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">        List&lt;Task&gt; existingTasksByType = allTasksByType.get(task.getType());</span><br><span class="line">        <span class="keyword">if</span> (existingTasksByType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Task&gt; tasksByType = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tasksByType.add(task);</span><br><span class="line">            allTasksByType.put(task.getType(), tasksByType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            existingTasksByType.add(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TaskType, List&lt;Task&gt;&gt; entry : allTasksByType.entrySet()) &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s =&gt;&gt; %s"</span>, entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收集器：常用的规约操作"><a href="#收集器：常用的规约操作" class="headerlink" title="收集器：常用的规约操作"></a>收集器：常用的规约操作</h2><p><code>Collectors</code>辅助类提供了大量的静态辅助方法来创建收集器为常见的使用场景服务，像将元素收集到一个集合中、分组和分割元素，或者根据不同的标准来概述元素。我们将在这篇博文中涵盖大部分常见的<code>Collector</code>。</p><h2 id="缩减为一个值"><a href="#缩减为一个值" class="headerlink" title="缩减为一个值"></a>缩减为一个值</h2><p>正如上面讨论的，收集器可以被用来收集流的输出到一个集合，或者产生一个单一的值。</p><h3 id="将数据收集进一个列表"><a href="#将数据收集进一个列表" class="headerlink" title="将数据收集进一个列表"></a>将数据收集进一个列表</h3><p>让我们编写我们的第一个测试用例——给定一个任务列表，我们想将他们的标题收集进一个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2_ReduceValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toList</code>收集器使用了列表的<code>add</code>方法来向结果列表中添加元素。<code>toList</code>收集器使用了<code>ArrayList</code>作为列表的实现。</p><h3 id="将数据收集进一个集合"><a href="#将数据收集进一个集合" class="headerlink" title="将数据收集进一个集合"></a>将数据收集进一个集合</h3><p>如果我们想要确保返回的标题都是唯一的，并且我们不在乎元素的顺序，那么我们可以使用<code>toSet</code>收集器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">uniqueTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(toSet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toSet</code>方法使用了<code>HashSet</code>作为集合的实现来存储结果集。</p><h3 id="将数据收集进一个映射"><a href="#将数据收集进一个映射" class="headerlink" title="将数据收集进一个映射"></a>将数据收集进一个映射</h3><p>你可以使用<code>toMap</code>收集器将一个流转换为一个映射。<code>toMap</code>收集器需要两个映射方法来获得映射的键和值。在下面展示的代码中，<code>Task::getTitle</code>是接收一个任务并产生一个只包含该任务标题的键的<code>Function</code>。<strong>task -&gt; task</strong>是一个用来返回任务本身的lambda表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, task -&gt; task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过使用<code>Function</code>接口中的默认方法<code>identity</code>来改进上面展示的代码，如下所示，这样可以让代码更加简洁，并更好地传达开发者的意图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.function.Function.identity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从一个流中创建映射的代码会在存在重复的键时抛出异常。你将会得到一个类似下面的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Duplicate key Task&#123;title&#x3D;&#39;Read Version Control with Git book&#39;, type&#x3D;READING&#125;</span><br><span class="line">at java.util.stream.Collectors.lambda$throwingMerger$105(Collectors.java:133)</span><br></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的另一个变体来处理重复问题，它允许我们指定一个合并方法。这个合并方法允许用户他们指定想如何处理多个值关联到同一个键的冲突。在下面展示的代码中，我们只是使用了新的值，当然你也可以编写一个智能的算法来处理冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Task&gt; <span class="title">taskMap_duplicates</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过使用<code>toMap</code>方法的第三个变体来指定其他的映射实现。这需要你指定将用来存储结果的<code>Map</code>和<code>Supplier</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, Task&gt; collectToMap(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">    return tasks.stream().collect(toMap(Task::getTitle, identity(), (t1, t2) -&gt; t2, LinkedHashMap::new));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于<code>toMap</code>收集器，也有<code>toConcurrentMap</code>收集器，它产生一个<code>ConcurrentMap</code>而不是<code>HashMap</code>。</p><h3 id="使用其它的收集器"><a href="#使用其它的收集器" class="headerlink" title="使用其它的收集器"></a>使用其它的收集器</h3><p>像<code>toList</code>和<code>toSet</code>这类特定的收集器不允许你指定内部的列表或者集合实现。当你想要将结果收集到其它类型的集合中时，你可以像下面这样使用<code>toCollection</code>收集器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static LinkedHashSet&lt;Task&gt; collectToLinkedHaskSet(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">  return tasks.stream().collect(toCollection(LinkedHashSet::new));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到拥有最长标题的任务"><a href="#找到拥有最长标题的任务" class="headerlink" title="找到拥有最长标题的任务"></a>找到拥有最长标题的任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">taskWithLongestTitle</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(collectingAndThen(maxBy((t1, t2) -&gt; t1.getTitle().length() - t2.getTitle().length()), Optional::get));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计标签的总数"><a href="#统计标签的总数" class="headerlink" title="统计标签的总数"></a>统计标签的总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalTagCount</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().collect(summingInt(task -&gt; task.getTags().size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成任务标题的概述"><a href="#生成任务标题的概述" class="headerlink" title="生成任务标题的概述"></a>生成任务标题的概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">titleSummary</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="string">";"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分类收集器"><a href="#分类收集器" class="headerlink" title="分类收集器"></a>分类收集器</h2><p>收集器最常见的使用场景之一是对元素进行分类。让我来看一下不同的例子来理解我们如何进行分类。</p><h3 id="例子1：根据类型对任务分类"><a href="#例子1：根据类型对任务分类" class="headerlink" title="例子1：根据类型对任务分类"></a>例子1：根据类型对任务分类</h3><p>我们看一下下面展示的例子，我们想要根据<code>TaskType</code>来对所有的任务进行分类。我们可以通过使用<code>Collectors</code>辅助类中的<code>groupingBy</code>方法来轻易地进行该项任务。你可以通过使用方法引用和静态导入来使它更加高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.groupingBy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, List&lt;Task&gt;&gt; groupTasksByType(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">       <span class="keyword">return</span> tasks.stream().collect(groupingBy(Task::getType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将会产生如下的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;CODING&#x3D;[Task&#123;title&#x3D;&#39;Write a mobile application to store my tasks&#39;, type&#x3D;CODING, createdOn&#x3D;2015-07-03&#125;], WRITING&#x3D;[Task&#123;title&#x3D;&#39;Write a blog on Java 8 Streams&#39;, type&#x3D;WRITING, createdOn&#x3D;2015-07-04&#125;], READING&#x3D;[Task&#123;title&#x3D;&#39;Read Version Control with Git book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-01&#125;, Task&#123;title&#x3D;&#39;Read Java 8 Lambdas book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-02&#125;, Task&#123;title&#x3D;&#39;Read Domain Driven Design book&#39;, type&#x3D;READING, createdOn&#x3D;2015-07-05&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：根据标签分类"><a href="#例子2：根据标签分类" class="headerlink" title="例子2：根据标签分类"></a>例子2：根据标签分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;Task&gt;&gt; groupingByTag(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().</span><br><span class="line">                flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="keyword">new</span> TaskTag(tag, task))).</span><br><span class="line">                collect(groupingBy(TaskTag::getTag, mapping(TaskTag::getTask,toList())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTag</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String tag;</span><br><span class="line">        <span class="keyword">final</span> Task task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TaskTag</span><span class="params">(String tag, Task task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="例子3：根据标签和数量对任务分类"><a href="#例子3：根据标签和数量对任务分类" class="headerlink" title="例子3：根据标签和数量对任务分类"></a>例子3：根据标签和数量对任务分类</h3><p>将分类器和收集器结合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Long&gt; <span class="title">tagsAndCount</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().</span><br><span class="line">        flatMap(task -&gt; task.getTags().stream().map(tag -&gt; <span class="keyword">new</span> TaskTag(tag, task))).</span><br><span class="line">        collect(groupingBy(TaskTag::getTag, counting()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="例子4：根据任务类型和创建日期分类"><a href="#例子4：根据任务类型和创建日期分类" class="headerlink" title="例子4：根据任务类型和创建日期分类"></a>例子4：根据任务类型和创建日期分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TaskType, Map&lt;LocalDate, List&lt;Task&gt;&gt;&gt; groupTasksByTypeAndCreationDate(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.stream().collect(groupingBy(Task::getType, groupingBy(Task::getCreatedOn)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>很多时候你想根据一个断言来将一个数据集分割成两个数据集。举例来说，我们可以通过定义一个将任务分割为两组的分割方法来将任务分割成两组，一组是在今天之前已经到期的，另一组是其他的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Boolean, List&lt;Task&gt;&gt; partitionOldAndFutureTasks(List&lt;Task&gt; tasks) &#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().collect(partitioningBy(task -&gt; task.getDueOn().isAfter(LocalDate.now())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成统计信息"><a href="#生成统计信息" class="headerlink" title="生成统计信息"></a>生成统计信息</h2><p>另一组非常有用的收集器是用来产生统计信息的收集器。这能够在像<code>int</code>、<code>double</code>和<code>long</code>这样的原始数据类型上起到作用；并且能被用来生成像下面这样的统计信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics summaryStatistics = tasks.stream().map(Task::getTitle).collect(summarizingInt(String::length));</span><br><span class="line">System.out.println(summaryStatistics.getAverage()); <span class="comment">//32.4</span></span><br><span class="line">System.out.println(summaryStatistics.getCount()); <span class="comment">//5</span></span><br><span class="line">System.out.println(summaryStatistics.getMax()); <span class="comment">//44</span></span><br><span class="line">System.out.println(summaryStatistics.getMin()); <span class="comment">//24</span></span><br><span class="line">System.out.println(summaryStatistics.getSum()); <span class="comment">//162</span></span><br></pre></td></tr></table></figure><p>也有其它的变种形式，像针对其它原生类型的<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>。</p><p>你也可以通过使用<code>combine</code>操作来将一个<code>IntSummaryStatistics</code>与另一个组合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstSummaryStatistics.combine(secondSummaryStatistics);</span><br><span class="line">System.out.println(firstSummaryStatistics)</span><br></pre></td></tr></table></figure><h2 id="连接所有的标题"><a href="#连接所有的标题" class="headerlink" title="连接所有的标题"></a>连接所有的标题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">allTitles</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tasks.stream().map(Task::getTitle).collect(joining(<span class="string">", "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个定制的收集器"><a href="#编写一个定制的收集器" class="headerlink" title="编写一个定制的收集器"></a>编写一个定制的收集器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.HashMultiset;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Multiset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultisetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Multiset</span>&lt;<span class="title">T</span>&gt;, <span class="title">Multiset</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Multiset&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> HashMultiset::create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Multiset&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (set, e) -&gt; set.add(e, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Multiset&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Multiset&lt;T&gt;, Multiset&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Multiset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultisetCollectorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">"shekhar"</span>, <span class="string">"rahul"</span>, <span class="string">"shekhar"</span>);</span><br><span class="line">        Multiset&lt;String&gt; set = names.stream().collect(<span class="keyword">new</span> MultisetCollector&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        set.forEach(str -&gt; System.out.println(str + <span class="string">":"</span> + set.count(str)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java8中的字数统计"><a href="#Java8中的字数统计" class="headerlink" title="Java8中的字数统计"></a>Java8中的字数统计</h2><p>我们将通过使用流和收集器在Java8中编写有名的字数统计样例来结束这一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wordCount</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Map&lt;String, Long&gt; wordCount = Files.lines(path)</span><br><span class="line">            .parallel()</span><br><span class="line">            .flatMap(line -&gt; Arrays.stream(line.trim().split(<span class="string">"\\s"</span>)))</span><br><span class="line">            .map(word -&gt; word.replaceAll(<span class="string">"[^a-zA-Z]"</span>, <span class="string">""</span>).toLowerCase().trim())</span><br><span class="line">            .filter(word -&gt; word.length() &gt; <span class="number">0</span>)</span><br><span class="line">            .map(word -&gt; <span class="keyword">new</span> SimpleEntry&lt;&gt;(word, <span class="number">1</span>))</span><br><span class="line">            .collect(groupingBy(SimpleEntry::getKey, counting()));</span><br><span class="line">    wordCount.forEach((k, v) -&gt; System.out.println(String.format(<span class="string">"%s ==&gt;&gt; %d"</span>, k, v)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;./2020/04/15/Stream-API/&quot;&gt;第二天&lt;/a&gt;，你已经学习了Stream API能够让你以声明式的方式帮助你处理集合。我们看到&lt;code&gt;collect&lt;/code&gt;是一个将管道流的结果集到一个&lt;code&gt;list&lt;/code&gt;中的结束操作。&lt;code&gt;collect&lt;/code&gt;是一个将数据流缩减为一个值的归约操作。这个值可以是集合、映射，或者一个值对象。你可以使用&lt;code&gt;collect&lt;/code&gt;达到以下目的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/categories/java/"/>
    
    
      <category term="java" scheme="http://ysocks.gitee.io/tags/java/"/>
    
  </entry>
  
</feed>
